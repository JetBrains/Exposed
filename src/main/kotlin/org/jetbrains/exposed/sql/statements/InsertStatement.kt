package org.jetbrains.exposed.sql.statements

import org.jetbrains.exposed.sql.*
import org.jetbrains.exposed.sql.vendors.currentDialect
import java.sql.PreparedStatement
import java.sql.ResultSet

/**
 * isIgnore is supported for mysql only
 */
open class InsertStatement<Key:Any>(val table: Table, val isIgnore: Boolean = false) : UpdateBuilder<Int>(StatementType.INSERT, listOf(table)) {
    open protected val flushCache = true
    protected var resultedValues: List<Map<Column<*>, Any>>? = null
    open val generatedKey: Key? get() = autoIncColumns.firstOrNull()?.let { get(it) } as Key?

    infix operator fun <T> get(column: Column<T>): T? = resultedValues?.get(0)?.get(column)?.let { column.columnType.valueFromDB(it )} as? T
            ?: if (!isIgnore) error("No key generated") else null

    private fun processResults(rs: ResultSet?, inserted: Int): List<Map<Column<*>, Any>> {
        val autoGeneratedKeys = arrayListOf<MutableMap<Column<*>, Any>>()

        val firstAutoIncColumn = autoIncColumns.firstOrNull()
        if (firstAutoIncColumn != null) {
            while (rs?.next() == true) {
                autoGeneratedKeys.add(hashMapOf(firstAutoIncColumn to rs.getObject(1)))
            }

            if (inserted > 1 && !currentDialect.supportsMultipleGeneratedKeys) {
                // H2/SQLite only returns one last generated key...
                (autoGeneratedKeys[0][firstAutoIncColumn] as? Number)?.toLong()?.let {
                    var id = it

                    while (autoGeneratedKeys.size < inserted) {
                        id -= 1
                        autoGeneratedKeys.add(0, hashMapOf(firstAutoIncColumn to id))
                    }
                }
            }

            /** FIXME: https://github.com/JetBrains/Exposed/issues/129
             *  doesn't work with MySQL `INSERT ... ON DUPLICATE UPDATE`
             */
//            assert(isIgnore || autoGeneratedKeys.isEmpty() || autoGeneratedKeys.size == inserted) {
//                "Number of autoincs (${autoGeneratedKeys.size}) doesn't match number of batch entries ($inserted)"
//            }
        }

        arguments!!.forEachIndexed { itemIndx, pairs ->
            pairs.forEach { (col, value) ->
                if (!col.columnType.isAutoInc) {
                    val map = autoGeneratedKeys.getOrElse(itemIndx) {
                        hashMapOf<Column<*>, Any>().apply {
                            autoGeneratedKeys.add(itemIndx, this)
                        }
                    }
                    if (col.defaultValueFun != null && value != null/* && data[itemIndx][col] == null*/) {
                        map[col] = value
                    }
                }
            }
        }
        return autoGeneratedKeys
    }

    open protected fun valuesAndDefaults(values: Map<Column<*>, Any?> = this.values): Map<Column<*>, Any?> {
        val columnsWithNotNullDefault = targets.flatMap { it.columns }.filter {
            (it.dbDefaultValue != null || it.defaultValueFun != null) && !it.columnType.nullable && it !in values.keys
        }
        return values + columnsWithNotNullDefault.map { it to (it.defaultValueFun?.invoke() ?: DefaultValueMarker) }
    }

    override fun prepareSQL(transaction: Transaction): String {
        val builder = QueryBuilder(true)
        val values = arguments!!.first()
        val sql = if(values.isEmpty()) ""
        else values.joinToString(prefix = "VALUES (", postfix = ")") { (col, value) ->
            builder.registerArgument(col, value)
        }
        return transaction.db.dialect.insert(isIgnore, table, values.map { it.first }, sql, transaction)
    }

    open protected fun PreparedStatement.execInsertFunction() : Pair<Int, ResultSet?> {
        val inserted = if (arguments().count() > 1 || isAlwaysBatch) executeBatch().sum() else executeUpdate()
        val rs = if (autoIncColumns.isNotEmpty()) { generatedKeys } else null
        return inserted to rs
    }

    override fun PreparedStatement.executeInternal(transaction: Transaction): Int {
        if (flushCache)
            transaction.flushCache()
        transaction.entityCache.removeTablesReferrers(listOf(table))
        val (inserted, rs) = execInsertFunction()
        return inserted.apply {
            resultedValues = processResults(rs, this)
        }
    }

    protected val autoIncColumns = targets.flatMap { it.columns }.filter { it.columnType.isAutoInc }

    override fun prepared(transaction: Transaction, sql: String): PreparedStatement {
        return if (autoIncColumns.isNotEmpty()) {
            // http://viralpatel.net/blogs/oracle-java-jdbc-get-primary-key-insert-sql/
            transaction.connection.prepareStatement(sql, autoIncColumns.map { transaction.identity(it) }.toTypedArray())!!
        } else {
            transaction.connection.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS)!!
        }
    }

    open protected var arguments: List<List<Pair<Column<*>, Any?>>>? = null
        get() = field ?: run {
            val nullableColumns = table.columns.filter { it.columnType.nullable }
            val valuesAndDefaults = valuesAndDefaults()
            val result = (valuesAndDefaults + (nullableColumns - valuesAndDefaults.keys).associate { it to null }).toList().sortedBy { it.first }
            listOf(result).apply { field = this }
        }

    override fun arguments() = arguments!!.map { it.map { it.first.columnType to it.second }.filter { it.second != DefaultValueMarker} }
}
