<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2024-10-30T15:56:55.037048351"><title>Data Types | Exposed</title><script type="application/json" id="virtual-toc-data">[{"id":"how-to-use-database-enum-types","level":0,"title":"How to use database ENUM types","anchor":"#how-to-use-database-enum-types"},{"id":"mysql-h2","level":1,"title":"MySQL, H2","anchor":"#mysql-h2"},{"id":"postgresql","level":1,"title":"PostgreSQL","anchor":"#postgresql"},{"id":"how-to-use-json-and-jsonb-types","level":0,"title":"How to use Json and JsonB types","anchor":"#how-to-use-json-and-jsonb-types"},{"id":"json-functions","level":1,"title":"Json Functions","anchor":"#json-functions"},{"id":"json-arrays","level":1,"title":"Json Arrays","anchor":"#json-arrays"},{"id":"how-to-use-array-types","level":0,"title":"How to use Array types","anchor":"#how-to-use-array-types"},{"id":"array-functions","level":1,"title":"Array Functions","anchor":"#array-functions"},{"id":"custom-data-types","level":0,"title":"Custom Data Types","anchor":"#custom-data-types"},{"id":"hierarchical-tree-like-data","level":1,"title":"Hierarchical tree-like data","anchor":"#hierarchical-tree-like-data"},{"id":"date-and-time-data","level":1,"title":"Date and time data","anchor":"#date-and-time-data"},{"id":"ranges-of-data","level":1,"title":"Ranges of data","anchor":"#ranges-of-data"},{"id":"predefined-string-data","level":1,"title":"Predefined string data","anchor":"#predefined-string-data"},{"id":"key-value-pair-data","level":1,"title":"Key-Value pair data","anchor":"#key-value-pair-data"},{"id":"case-insensitive-data","level":1,"title":"Case insensitive data","anchor":"#case-insensitive-data"},{"id":"column-transformation","level":0,"title":"Column transformation","anchor":"#column-transformation"},{"id":"null-transform","level":1,"title":"Null transform","anchor":"#null-transform"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b267/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Data Types | Exposed"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Exposed Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/docs/0.56.0/data-types.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Data Types | Exposed"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/docs/0.56.0/data-types.html#webpage",
    "url": "writerside-documentation/docs/0.56.0/data-types.html",
    "name": "Data Types | Exposed",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/docs/#website",
    "url": "writerside-documentation/docs/",
    "name": "Exposed Help"
}</script><!-- End Schema.org --></head><body data-id="Data-Types" data-main-title="Data Types" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Schemas"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Exposed 0.56.0 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Data-Types" id="Data-Types.topic">Data Types</h1><p id="-yo0vxf_2">Exposed supports the following data types in the table definition:</p><ul class="list _bullet" id="-yo0vxf_3"><li class="list__item" id="-yo0vxf_4"><p><code class="code" id="-yo0vxf_5">integer</code> - translates to DB <code class="code" id="-yo0vxf_6">INT</code></p></li><li class="list__item" id="-yo0vxf_7"><p><code class="code" id="-yo0vxf_8">short</code> - translates to DB <code class="code" id="-yo0vxf_9">SMALLINT</code></p></li><li class="list__item" id="-yo0vxf_10"><p><code class="code" id="-yo0vxf_11">long</code> - <code class="code" id="-yo0vxf_12">BIGINT</code></p></li><li class="list__item" id="-yo0vxf_13"><p><code class="code" id="-yo0vxf_14">float</code> - <code class="code" id="-yo0vxf_15">FLOAT</code></p></li><li class="list__item" id="-yo0vxf_16"><p><code class="code" id="-yo0vxf_17">decimal</code> - <code class="code" id="-yo0vxf_18">DECIMAL</code> with scale and precision</p></li><li class="list__item" id="-yo0vxf_19"><p><code class="code" id="-yo0vxf_20">bool</code> - <code class="code" id="-yo0vxf_21">BOOLEAN</code></p></li><li class="list__item" id="-yo0vxf_22"><p><code class="code" id="-yo0vxf_23">char</code> - <code class="code" id="-yo0vxf_24">CHAR</code></p></li><li class="list__item" id="-yo0vxf_25"><p><code class="code" id="-yo0vxf_26">varchar</code> - <code class="code" id="-yo0vxf_27">VARCHAR</code> with length</p></li><li class="list__item" id="-yo0vxf_28"><p><code class="code" id="-yo0vxf_29">text</code> - <code class="code" id="-yo0vxf_30">TEXT</code></p></li><li class="list__item" id="-yo0vxf_31"><p><code class="code" id="-yo0vxf_32">enumeration</code> - <code class="code" id="-yo0vxf_33">INT</code> ordinal value</p></li><li class="list__item" id="-yo0vxf_34"><p><code class="code" id="-yo0vxf_35">enumerationByName</code> - <code class="code" id="-yo0vxf_36">VARCHAR</code></p></li><li class="list__item" id="-yo0vxf_37"><p><code class="code" id="-yo0vxf_38">customEnumeration</code> - see <a href="#how-to-use-database-enum-types" id="-yo0vxf_39" data-tooltip="Some of the databases (e.g. MySQL, PostgreSQL, H2) support explicit ENUM types. Because keeping such columns in sync with Kotlin enumerations using only JDBC metadata could be a huge challenge, Exposed doesn't provide a possibility to manage such columns in an automatic way, butâ€¦">additional section</a></p></li><li class="list__item" id="-yo0vxf_40"><p><code class="code" id="-yo0vxf_41">blob</code> - <code class="code" id="-yo0vxf_42">BLOB</code></p></li><li class="list__item" id="-yo0vxf_43"><p><code class="code" id="-yo0vxf_44">binary</code> - <code class="code" id="-yo0vxf_45">VARBINARY</code> with length</p></li><li class="list__item" id="-yo0vxf_46"><p><code class="code" id="-yo0vxf_47">uuid</code> - <code class="code" id="-yo0vxf_48">BINARY(16)</code></p></li><li class="list__item" id="-yo0vxf_49"><p><code class="code" id="-yo0vxf_50">reference</code> - a foreign key</p></li><li class="list__item" id="-yo0vxf_51"><p><code class="code" id="-yo0vxf_52">array</code> - <code class="code" id="-yo0vxf_53">ARRAY</code></p></li></ul><p id="-yo0vxf_54">The <code class="code" id="-yo0vxf_55">exposed-java-time</code> extension (<code class="code" id="-yo0vxf_56">org.jetbrains.exposed:exposed-java-time:$exposed_version</code>) provides additional types:</p><ul class="list _bullet" id="-yo0vxf_57"><li class="list__item" id="-yo0vxf_58"><p><code class="code" id="-yo0vxf_59">date</code> - <code class="code" id="-yo0vxf_60">DATETIME</code></p></li><li class="list__item" id="-yo0vxf_61"><p><code class="code" id="-yo0vxf_62">time</code> - <code class="code" id="-yo0vxf_63">TIME</code></p></li><li class="list__item" id="-yo0vxf_64"><p><code class="code" id="-yo0vxf_65">datetime</code> - <code class="code" id="-yo0vxf_66">DATETIME</code></p></li><li class="list__item" id="-yo0vxf_67"><p><code class="code" id="-yo0vxf_68">timestamp</code> - <code class="code" id="-yo0vxf_69">TIMESTAMP</code></p></li><li class="list__item" id="-yo0vxf_70"><p><code class="code" id="-yo0vxf_71">duration</code> - <code class="code" id="-yo0vxf_72">DURATION</code></p></li></ul><aside class="prompt" data-type="note" data-title="" id="-yo0vxf_73"><p>Some types are different for specific DB dialect.</p></aside><p id="-yo0vxf_74">The <code class="code" id="-yo0vxf_75">exposed-json</code> extension (<code class="code" id="-yo0vxf_76">org.jetbrains.exposed:exposed-json:$exposed_version</code>) provides additional types (see <a href="#how-to-use-json-and-jsonb-types" id="-yo0vxf_77" data-tooltip="Add the following dependencies to your build.gradle.kts:">how to use</a>):</p><ul class="list _bullet" id="-yo0vxf_78"><li class="list__item" id="-yo0vxf_79"><p><code class="code" id="-yo0vxf_80">json</code> - <code class="code" id="-yo0vxf_81">JSON</code></p></li><li class="list__item" id="-yo0vxf_82"><p><code class="code" id="-yo0vxf_83">jsonb</code> - <code class="code" id="-yo0vxf_84">JSONB</code></p></li></ul><aside class="prompt" data-type="note" data-title="" id="-yo0vxf_85"><p>Databases store JSON values either in text or binary format, so Exposed provides two types to account for any potential differences, if they exist, for example: </p><ul class="list _bullet" id="-yo0vxf_86"><li class="list__item" id="-yo0vxf_87"><p><span class="control" id="-yo0vxf_88">PostgreSQL</span>: <code class="code" id="-yo0vxf_89">json()</code> maps to <code class="code" id="-yo0vxf_90">JSON</code>, while <code class="code" id="-yo0vxf_91">jsonb()</code> maps to <code class="code" id="-yo0vxf_92">JSONB</code>.</p></li><li class="list__item" id="-yo0vxf_93"><p><span class="control" id="-yo0vxf_94">SQLite</span>: No native JSON type, so <code class="code" id="-yo0vxf_95">json()</code> maps to TEXT, while <code class="code" id="-yo0vxf_96">jsonb()</code> throws.</p></li><li class="list__item" id="-yo0vxf_97"><p><span class="control" id="-yo0vxf_98">MySQL</span>: JSON type only supports binary format, so <code class="code" id="-yo0vxf_99">json()</code> and <code class="code" id="-yo0vxf_100">jsonb()</code> both map to JSON.</p></li><li class="list__item" id="-yo0vxf_101"><p><span class="control" id="-yo0vxf_102">Oracle</span>: Exposed does not currently support the JSON binary format of Oracle 21c; only text format <code class="code" id="-yo0vxf_103">json()</code> can be used.</p></li></ul></aside><section class="chapter"><h2 id="how-to-use-database-enum-types" data-toc="how-to-use-database-enum-types">How to use database ENUM types</h2><p id="-yo0vxf_104">Some of the databases (e.g. MySQL, PostgreSQL, H2) support explicit ENUM types. Because keeping such columns in sync with Kotlin enumerations using only JDBC metadata could be a huge challenge, Exposed doesn't provide a possibility to manage such columns in an automatic way, but that doesn't mean that you can't use such column types.</p><p id="-yo0vxf_105">You have two options to work with ENUM database types and you should use <code class="code" id="-yo0vxf_106">customEnumeration()</code> (available since version 0.10.3) in both cases:</p><ol class="list _decimal" id="-yo0vxf_107" type="1"><li class="list__item" id="-yo0vxf_108"><p>Use an existing ENUM column from your table. In this case, the <code class="code" id="-yo0vxf_109">sql</code> parameter in <code class="code" id="-yo0vxf_110">customEnumeration()</code> can be left as <code class="code" id="-yo0vxf_111">null</code>.</p></li><li class="list__item" id="-yo0vxf_112"><p>Create a new ENUM column using Exposed by providing the raw definition SQL to the <code class="code" id="-yo0vxf_113">sql</code> parameter in <code class="code" id="-yo0vxf_114">customEnumeration()</code>.</p></li></ol><p id="-yo0vxf_115">As a JDBC driver can provide/expect specific classes for ENUM types, you must also provide from/to transformation functions for them when defining a <code class="code" id="-yo0vxf_116">customEnumeration</code>.</p><p id="-yo0vxf_117">For a class like <code class="code" id="-yo0vxf_118">enum class Foo { BAR, BAZ }</code>, you can use the provided code below for your specific database:</p><section class="chapter"><h3 id="mysql-h2" data-toc="mysql-h2">MySQL, H2</h3><div class="code-block" data-lang="kotlin">
                val existingEnumColumn = customEnumeration(&quot;enumColumn&quot;, { value -&gt; Foo.valueOf(value as String) }, { it.name })
                val newEnumColumn = customEnumeration(&quot;enumColumn&quot;, &quot;ENUM('BAR', 'BAZ')&quot;, { value -&gt; Foo.valueOf(value as String) }, { it.name })
            </div></section><section class="chapter"><h3 id="postgresql" data-toc="postgresql">PostgreSQL</h3><p id="-yo0vxf_120">PostgreSQL requires that ENUM is defined as a separate type, so you have to create it before creating your table. Also, the PostgreSQL JDBC driver returns <code class="code" id="-yo0vxf_121">PGobject</code> instances for such values, so a <code class="code" id="-yo0vxf_122">PGobject</code> with its type manually set to the ENUM type needs to be used for the <code class="code" id="-yo0vxf_123">toDb</code> parameter. The full working sample is provided below:</p><div class="code-block" data-lang="kotlin">
                class PGEnum&lt;T : Enum&lt;T&gt;&gt;(enumTypeName: String, enumValue: T?) : PGobject() {
                    init {
                        value = enumValue?.name
                        type = enumTypeName
                    }
                }

                object EnumTable : Table() {
                    val enumColumn = customEnumeration(&quot;enumColumn&quot;, &quot;FooEnum&quot;, { value -&gt; Foo.valueOf(value as String) }, { PGEnum(&quot;FooEnum&quot;, it) })
                }

                transaction {
                    exec(&quot;CREATE TYPE FooEnum AS ENUM ('BAR', 'BAZ');&quot;)
                    SchemaUtils.create(EnumTable)
                }
            </div></section></section><section class="chapter"><h2 id="how-to-use-json-and-jsonb-types" data-toc="how-to-use-json-and-jsonb-types">How to use Json and JsonB types</h2><p id="-yo0vxf_125">Add the following dependencies to your <code class="code" id="-yo0vxf_126">build.gradle.kts</code>:</p><div class="code-block" data-lang="kotlin">
            val exposedVersion: String by project

            dependencies {
                implementation(&quot;org.jetbrains.exposed:exposed-core:$exposedVersion&quot;)
                implementation(&quot;org.jetbrains.exposed:exposed-json:$exposedVersion&quot;)
            }
        </div><p id="-yo0vxf_128">Exposed works together with the JSON serialization/deserialization library of your choice by allowing column definitions that accept generic serializer and deserializer arguments:</p><div class="code-block" data-lang="kotlin">
            fun &lt;T : Any&gt; json(name: String, serialize: (T) -&gt; String, deserialize: (String) -&gt; T): Column&lt;T&gt;

            fun &lt;T : Any&gt; jsonb(name: String, serialize: (T) -&gt; String, deserialize: (String) -&gt; T): Column&lt;T&gt;
        </div><p id="-yo0vxf_130">Here's an example that leverages <a href="https://github.com/Kotlin/kotlinx.serialization" id="-yo0vxf_131" data-external="true" rel="noopener noreferrer">kotlinx.serialization</a> to support <code class="code" id="-yo0vxf_132">@Serializable</code> classes. It uses a simpler form of <code class="code" id="-yo0vxf_133">json()</code> that relies on the library's <code class="code" id="-yo0vxf_134">KSerializer</code> interface:</p><div class="code-block" data-lang="kotlin">
            @Serializable
            data class Project(val name: String, val language: String, val active: Boolean)

            val format = Json { prettyPrint = true }

            object Teams : Table(&quot;team&quot;) {
                val groupId = varchar(&quot;group_id&quot;, 32)
                val project = json&lt;Project&gt;(&quot;project&quot;, format) // equivalent to json(&quot;project&quot;, format, Project.serializer())
            }

            transaction {
                val mainProject = Project(&quot;Main&quot;, &quot;Java&quot;, true)
                Teams.insert {
                    it[groupId] = &quot;A&quot;
                    it[project] = mainProject
                }
                Teams.update({ Teams.groupId eq &quot;A&quot; }) {
                    it[project] = mainProject.copy(language = &quot;Kotlin&quot;)
                }

                Teams.selectAll().map { &quot;Team ${it[Teams.groupId]} -&gt; ${it[Teams.project]}&quot; }.forEach { println(it) }
                // Team A -&gt; Project(name=Main, language=Kotlin, active=true)
            }
        </div><p id="-yo0vxf_136">Here's how the same <code class="code" id="-yo0vxf_137">Project</code> and <code class="code" id="-yo0vxf_138">Teams</code> would be defined using <a href="https://github.com/FasterXML/jackson" id="-yo0vxf_139" data-external="true" rel="noopener noreferrer">Jackson</a> with the <code class="code" id="-yo0vxf_140">jackson-module-kotlin</code> dependency and the full form of <code class="code" id="-yo0vxf_141">json()</code>:</p><div class="code-block" data-lang="kotlin">
            val mapper = jacksonObjectMapper()

            data class Project(val name: String, val language: String, val active: Boolean)

            object Teams : Table(&quot;team&quot;) {
                val groupId = varchar(&quot;group_id&quot;, 32)
                val project = json(&quot;project&quot;, { mapper.writeValueAsString(it) }, { mapper.readValue&lt;Project&gt;(it) })
            }
        </div><section class="chapter"><h3 id="json-functions" data-toc="json-functions">Json Functions</h3><p id="-yo0vxf_143">JSON path strings can be used to extract values (either as JSON or as a scalar value) at a specific field/key:</p><div class="code-block" data-lang="kotlin">
                val projectName = Teams.project.extract&lt;String&gt;(&quot;name&quot;)
                val languageIsKotlin = Teams.project.extract&lt;String&gt;(&quot;language&quot;).lowerCase() eq &quot;kotlin&quot;
                Teams.select(projectName).where { languageIsKotlin }.map { it[projectName] }
            </div><aside class="prompt" data-type="note" data-title="" id="-yo0vxf_145"><p>Databases that support a path context root <code class="code" id="-yo0vxf_146">$</code> will have this value appended to the generated SQL path expression by default, so it is not necessary to include it in the provided argument String. In the above example, if MySQL is being used, the provided path arguments should be <code class="code" id="-yo0vxf_147">.name</code> and <code class="code" id="-yo0vxf_148">.language</code> respectively.</p></aside><p id="-yo0vxf_149">The JSON functions <code class="code" id="-yo0vxf_150">exists()</code> and <code class="code" id="-yo0vxf_151">contains()</code> are currently supported as well:</p><div class="code-block" data-lang="kotlin">
                val hasActiveStatus = Teams.project.exists(&quot;.active&quot;)
                val activeProjects = Teams.selectAll().where { hasActiveStatus }.count()

                // Depending on the database, filter paths can be provided instead, as well as optional arguments
                // PostgreSQL example
                val mainId = &quot;Main&quot;
                val hasMainProject = Teams.project.exists(&quot;.name ? (@ == \$main)&quot;, optional = &quot;{\&quot;main\&quot;:\&quot;$mainId\&quot;}&quot;)
                val mainProjects = Teams.selectAll().where { hasMainProject }.map { it[Teams.groupId] }

                val usesKotlin = Teams.project.contains(&quot;{\&quot;language\&quot;:\&quot;Kotlin\&quot;}&quot;)
                val kotlinTeams = Teams.selectAll().where { usesKotlin }.count()

                // Depending on the database, an optional path can be provided too
                // MySQL example
                val usesKotlin = Teams.project.contains(&quot;\&quot;Kotlin\&quot;&quot;, &quot;.language&quot;)
                val kotlinTeams = Teams.selectAll().where { usesKotlin }.count()
            </div></section><section class="chapter"><h3 id="json-arrays" data-toc="json-arrays">Json Arrays</h3><p id="-yo0vxf_153">JSON columns also accept JSON arrays as input values. For example, using the serializable data class <code class="code" id="-yo0vxf_154">Project</code> from the example above, the following details some ways to create such a column:</p><div class="code-block" data-lang="kotlin">
                object TeamProjects : Table(&quot;team_projects&quot;) {
                    val memberIds = json&lt;IntArray&gt;(&quot;member_ids&quot;, Json.Default)
                    val projects = json&lt;Array&lt;Project&gt;&gt;(&quot;projects&quot;, Json.Default)
                    // equivalent to:
                    // @OptIn(ExperimentalSerializationApi::class) json(&quot;projects&quot;, Json.Default, ArraySerializer(Project.serializer()))
                }

                transaction {
                    TeamProjects.insert {
                        it[memberIds] = intArrayOf(1, 2, 3)
                        it[projects] = arrayOf(
                            Project(&quot;A&quot;, &quot;Kotlin&quot;, true),
                            Project(&quot;B&quot;, &quot;Java&quot;, true)
                        )
                    }
                    // generates SQL
                    // INSERT INTO team_projects (member_ids, projects) VALUES ([1,2,3], [{&quot;name&quot;:&quot;A&quot;,&quot;language&quot;:&quot;Kotlin&quot;,&quot;active&quot;:true},{&quot;name&quot;:&quot;B&quot;,&quot;language&quot;:&quot;Java&quot;,&quot;active&quot;:true}])
                }
            </div></section></section><section class="chapter"><h2 id="how-to-use-array-types" data-toc="how-to-use-array-types">How to use Array types</h2><p id="-yo0vxf_156">PostgreSQL and H2 databases support the explicit ARRAY data type, with multi-dimensional arrays being supported by PostgreSQL.</p><p id="-yo0vxf_157">Exposed allows defining columns as arrays, with the stored contents being any out-of-the-box or custom data type. If the contents are of a type with a supported <code class="code" id="-yo0vxf_158">ColumnType</code> in the <code class="code" id="-yo0vxf_159">exposed-core</code> module, the column can be simply defined with that type:</p><div class="code-block" data-lang="kotlin">
            object Teams : Table(&quot;teams&quot;) {
                // Single-dimensional arrays
                val memberIds = array&lt;UUID&gt;(&quot;member_ids&quot;)
                val memberNames = array&lt;String&gt;(&quot;member_names&quot;)
                val budgets = array&lt;Double&gt;(&quot;budgets&quot;)

                // Multi-dimensional arrays
                val nestedMemberIds = array&lt;UUID, List&lt;List&lt;UUID&gt;&gt;&gt;(
                    &quot;nested_member_ids&quot;, dimensions = 2
                )
                val hierarchicalMemberNames = array&lt;String, List&lt;List&lt;List&lt;String&gt;&gt;&gt;&gt;(
                    &quot;hierarchical_member_names&quot;, dimensions = 3
                )
            }
        </div><p id="-yo0vxf_161">If more control is needed over the base content type, or if the latter is user-defined or from a non-core module, the explicit type should be provided to the function:</p><div class="code-block" data-lang="kotlin">
            object Teams : Table(&quot;teams&quot;) {
                // Single-dimensional arrays
                val memberNames = array&lt;String&gt;(&quot;member_names&quot;, VarCharColumnType(colLength = 32))
                val deadlines = array&lt;LocalDate&gt;(&quot;deadlines&quot;, KotlinLocalDateColumnType()).nullable()
                val expenses = array&lt;Double?&gt;(&quot;expenses&quot;, DoubleColumnType()).default(emptyList())

                // Multi-dimensional arrays
                val nestedMemberIds = array&lt;UUID, List&lt;List&lt;UUID&gt;&gt;&gt;(
                    &quot;nested_member_ids&quot;, dimensions = 2
                )
                val hierarchicalMemberNames = array&lt;String, List&lt;List&lt;List&lt;String&gt;&gt;&gt;&gt;(
                    &quot;hierarchical_member_names&quot;,
                    VarCharColumnType(colLength = 32),
                    dimensions = 3
                )
            }
        </div><p id="-yo0vxf_163">This will prevent an exception being thrown if Exposed cannot find an associated column mapping for the defined type. Null array contents are allowed, and the explicit column type should be provided for these columns as well.</p><p id="-yo0vxf_164">An array column accepts inserts and retrieves stored array contents as a Kotlin <code class="code" id="-yo0vxf_165">List</code>:</p><div class="code-block" data-lang="kotlin">
            Teams.insert {
                // Single-dimensional arrays
                it[memberIds] = List(5) { UUID.randomUUID() }
                it[memberNames] = List(5) { i -&gt; &quot;Member ${'A' + i}&quot; }
                it[budgets] = listOf(9999.0)

                // Multi-dimensional arrays
                it[nestedMemberIds] = List(5) { List(5) { UUID.randomUUID() } }
                it[hierarchicalMemberNames] = List(3) { List(3) { List(3) {
                        i -&gt; &quot;Member ${'A' + i}&quot;
                } } }
            }
        </div><section class="chapter"><h3 id="array-functions" data-toc="array-functions">Array Functions</h3><p id="-yo0vxf_167">A single element in a stored array can be accessed using the index reference <code class="code" id="-yo0vxf_168">get()</code> operator:</p><div class="code-block" data-lang="kotlin">
                val firstMember = Teams.memberIds[1]
                Teams
                    .select(firstMember)
                    .where { Teams.expenses[1] greater Teams.budgets[1] }
            </div><p id="-yo0vxf_170">This also applies to multidimensional arrays:</p><div class="code-block" data-lang="kotlin">
                Teams
                    .selectAll()
                    .where { Teams.hierarchicalMemberNames[1][1] eq &quot;Mr. Smith&quot; }
            </div><aside class="prompt" data-type="note" data-title="" id="-yo0vxf_172"><p>Both PostgreSQL and H2 use a one-based indexing convention, so the first element is retrieved by using index 1.</p></aside><p id="-yo0vxf_173">A new subarray can also be accessed by using <code class="code" id="-yo0vxf_174">slice()</code>, which takes a lower and upper bound (inclusive):</p><div class="code-block" data-lang="kotlin">
                Teams.select(Teams.deadlines.slice(1, 3))
            </div><p id="-yo0vxf_176">In the case of multidimensional arrays, the <code class="code" id="-yo0vxf_177">slice()</code> calls can be nested:</p><div class="code-block" data-lang="kotlin">
                Teams.select(Teams.hierarchicalMemberNames.slice(1, 2).slice(3, 4))
            </div><p id="-yo0vxf_179">Both arguments for these bounds are optional if using PostgreSQL.</p><p id="-yo0vxf_180">An array column can also be used as an argument for the <code class="code" id="-yo0vxf_181">ANY</code> and <code class="code" id="-yo0vxf_182">ALL</code> SQL operators, either by providing the entire column or a new array expression via <code class="code" id="-yo0vxf_183">slice()</code>:</p><div class="code-block" data-lang="kotlin">
                Teams
                    .selectAll()
                    .where { Teams.budgets[1] lessEq allFrom(Teams.expenses) }

                Teams
                    .selectAll()
                    .where { stringParam(&quot;Member A&quot;) eq anyFrom(Teams.memberNames.slice(1, 4)) }
            </div></section></section><section class="chapter"><h2 id="custom-data-types" data-toc="custom-data-types">Custom Data Types</h2><p id="-yo0vxf_185">If a database-specific data type is not immediately supported by Exposed, any existing and open column type class can be extended or a custom <code class="code" id="-yo0vxf_186">ColumnType</code> class can be implemented to achieve the same functionality.</p><p id="-yo0vxf_187">The following examples describe different ways to customize a column type, register a column with the custom type, and then start using it in transactions.</p><section class="chapter"><h3 id="hierarchical-tree-like-data" data-toc="hierarchical-tree-like-data">Hierarchical tree-like data</h3><p id="-yo0vxf_188">PostgreSQL provides a data type, <a href="https://www.postgresql.org/docs/current/ltree.html" id="-yo0vxf_189" data-external="true" rel="noopener noreferrer"><code class="code" id="-yo0vxf_190">ltree</code></a>, to represent hierarchical tree-like data.</p><p id="-yo0vxf_191">The hierarchy labels are stored as strings, so the existing <code class="code" id="-yo0vxf_192">StringColumnType</code> class be extended with a few overrides:</p><div class="code-block" data-lang="kotlin">
                import org.postgresql.util.PGobject

                class LTreeColumnType : StringColumnType() {
                    override fun sqlType(): String = &quot;LTREE&quot;

                    override fun setParameter(stmt: PreparedStatementApi, index: Int, value: Any?) {
                        val parameterValue: PGobject? = value?.let {
                            PGobject().apply {
                                type = sqlType()
                                this.value = value as? String
                            }
                        }
                        super.setParameter(stmt, index, parameterValue)
                    }
                }
            </div><aside class="prompt" data-type="note" data-title="" id="-yo0vxf_194"><p>When setting an object in a prepared statement with JDBC, any unknown data type without a JDBC mapping is set as a varying character string. To avoid a casting exception due to PostgreSQL's stricter type system, the type of the set parameter should be manually declared, by using a <code class="code" id="-yo0vxf_195">PGobject</code> in <code class="code" id="-yo0vxf_196">setParamater()</code>, as shown in the example above.</p></aside><p id="-yo0vxf_197">A table extension function can then be added to register a new column with this type:</p><div class="code-block" data-lang="kotlin">
                fun Table.ltree(name: String): Column&lt;String&gt; = registerColumn(name, LTreeColumnType())

                object TestTable : Table(&quot;test_table&quot;) {
                    val path = ltree(&quot;path&quot;)

                    init {
                        index(customIndexName = &quot;path_gist_idx&quot;, indexType = &quot;GIST&quot;, columns = arrayOf(path))
                        index(customIndexName = &quot;path_idx&quot;, indexType = &quot;BTREE&quot;, columns = arrayOf(path))
                    }
                }
            </div><aside class="prompt" data-type="note" data-title="" id="-yo0vxf_199"><p>To use the <code class="code" id="-yo0vxf_200">ltree</code> data type, the extension must first be enabled in the database by running <code class="code" id="-yo0vxf_201">exec(&quot;CREATE EXTENSION ltree;&quot;)</code>.</p></aside><p id="-yo0vxf_202">String values representing hierarchy labels can then be inserted and queried from the <code class="code" id="-yo0vxf_203">path</code> column. The following block shows an update of all records that have a stored <code class="code" id="-yo0vxf_204">path</code> either equal to or a descendant of the path <code class="code" id="-yo0vxf_205">Top.Science</code>, by setting a subpath of the first 2 labels as the updated value:</p><div class="code-block" data-lang="kotlin">
                transaction {
                    TestTable.update(
                        where = { TestTable.path isDescendantOrEq &quot;Top.Science&quot; }
                    ) {
                        it[path] = path.subltree(0, 2)
                    }
                }

                fun &lt;T : String?&gt; Expression&lt;T&gt;.subltree(start: Int, end: Int) =
                    CustomStringFunction(&quot;SUBLTREE&quot;, this, intParam(start), intParam(end))

                infix fun &lt;T : String?&gt; ExpressionWithColumnType&lt;T&gt;.isDescendantOrEq(other: T) =
                    IsDescendantOrEqOp(this, wrap(other))

                class IsDescendantOrEqOp&lt;T : String?&gt;(
                    left: Expression&lt;T&gt;,
                    right: Expression&lt;T&gt;
                ) : ComparisonOp(left, right, &quot;&lt;@&quot;)
            </div></section><section class="chapter"><h3 id="date-and-time-data" data-toc="date-and-time-data">Date and time data</h3><p id="-yo0vxf_207">MySQL and MariaDB provide a data type, <a href="https://dev.mysql.com/doc/refman/8.4/en/year.html" id="-yo0vxf_208" data-external="true" rel="noopener noreferrer"><code class="code" id="-yo0vxf_209">YEAR</code></a>, for 1-byte storage of year values in the range of 1901 to 2155.</p><p id="-yo0vxf_210">This example assumes that the column accepts string input values, but a numerical format is also possible, in which case <code class="code" id="-yo0vxf_211">IntegerColumnType</code> could be extended instead:</p><div class="code-block" data-lang="kotlin">
                class YearColumnType : StringColumnType(), IDateColumnType {
                    override fun sqlType(): String = &quot;YEAR&quot;

                    override val hasTimePart: Boolean = false

                    override fun valueFromDB(value: Any): String = when (value) {
                        is java.sql.Date -&gt; value.toString().substringBefore('-')
                        else -&gt; error(&quot;Retrieved unexpected value of type ${value::class.simpleName}&quot;)
                    }
                }

                fun Table.year(name: String): Column&lt;String&gt; = registerColumn(name, YearColumnType())
            </div><p id="-yo0vxf_213">The <code class="code" id="-yo0vxf_214">IDateColumnType</code> interface is implemented to ensure that any default expressions are handled appropriately. For example, a new object <code class="code" id="-yo0vxf_215">CurrentYear</code> can be added as a default to avoid issues with the strict column typing:</p><div class="code-block" data-lang="kotlin">
                object CurrentYear : Function&lt;String&gt;(YearColumnType()) {
                    override fun toQueryBuilder(queryBuilder: QueryBuilder) {
                        queryBuilder { +&quot;CURRENT_DATE&quot; }
                    }
                }

                object TestTable : Table(&quot;test_table&quot;) {
                    val established = year(&quot;established&quot;).defaultExpression(CurrentYear)
                }
            </div><p id="-yo0vxf_217">String values of different formats (depending on the enabled <code class="code" id="-yo0vxf_218">sql_mode</code>) can then be inserted and queried from the <code class="code" id="-yo0vxf_219">year</code> column:</p><div class="code-block" data-lang="kotlin">
                transaction {
                    // disable strict mode to allow truncation of full date strings
                    exec(&quot;SET sql_mode=''&quot;)

                    val yearData = listOf(&quot;1901&quot;, &quot;2000&quot;, &quot;2023-08-22&quot;, &quot;2155&quot;)
                    TestTable.batchInsert(yearData) { year -&gt;
                        this[TestTable.established] = year
                    }

                    TestTable
                        .selectAll()
                        .where { TestTable.established less CurrentYear }
                        .toList()
                }
            </div></section><section class="chapter"><h3 id="ranges-of-data" data-toc="ranges-of-data">Ranges of data</h3><p id="-yo0vxf_221">PostgreSQL provides multiple <a href="https://www.postgresql.org/docs/16/rangetypes.html" id="-yo0vxf_222" data-external="true" rel="noopener noreferrer">range data types</a> of different subtypes.</p><p id="-yo0vxf_223">If more than one range subtype needs to be used, a base <code class="code" id="-yo0vxf_224">RangeColumnType</code> class could be first introduced with the minimum common logic:</p><div class="code-block" data-lang="kotlin">
                import org.postgresql.util.PGobject

                abstract class RangeColumnType&lt;T : Comparable&lt;T&gt;, R : ClosedRange&lt;T&gt;&gt;(
                    val subType: ColumnType&lt;T&gt;,
                ) : ColumnType&lt;R&gt;() {
                    abstract fun List&lt;String&gt;.toRange(): R

                    override fun nonNullValueToString(value: R): String {
                        return &quot;[${value.start},${value.endInclusive}]&quot;
                    }

                    override fun nonNullValueAsDefaultString(value: R): String {
                        return &quot;'${nonNullValueToString(value)}'&quot;
                    }

                    override fun setParameter(stmt: PreparedStatementApi, index: Int, value: Any?) {
                        val parameterValue: PGobject? = value?.let {
                            PGobject().apply {
                                type = sqlType()
                                this.value = nonNullValueToString(it as R)
                            }
                        }
                        super.setParameter(stmt, index, parameterValue)
                    }

                    override fun valueFromDB(value: Any): R? = when (value) {
                        is PGobject -&gt; value.value?.let {
                            val components = it.trim('[', ')').split(',')
                            components.toRange()
                        }
                        else -&gt; error(&quot;Retrieved unexpected value of type ${value::class.simpleName}&quot;)
                    }
                }
            </div><p id="-yo0vxf_226">A class for the type <code class="code" id="-yo0vxf_227">int4range</code> that accepts <code class="code" id="-yo0vxf_228">IntRange</code> values could then be implemented:</p><div class="code-block" data-lang="kotlin">
                class IntRangeColumnType : RangeColumnType&lt;Int, IntRange&gt;(IntegerColumnType()) {
                    override fun sqlType(): String = &quot;INT4RANGE&quot;

                    override fun List&lt;String&gt;.toRange(): IntRange {
                        return IntRange(first().toInt(), last().toInt() - 1)
                    }
                }

                fun Table.intRange(name: String): Column&lt;IntRange&gt; = registerColumn(name, IntRangeColumnType())
            </div><p id="-yo0vxf_230">If a custom Kotlin implementation for a <code class="code" id="-yo0vxf_231">DateRange</code> is set up (using <code class="code" id="-yo0vxf_232">Iterable</code> and <code class="code" id="-yo0vxf_233">ClosedRange</code>), then a class for the type <code class="code" id="-yo0vxf_234">daterange</code> can also be added. This implementation would require a dependency on <code class="code" id="-yo0vxf_235">exposed-kotlin-datetime</code>:</p><div class="code-block" data-lang="kotlin">
                class DateRangeColumnType : RangeColumnType&lt;LocalDate, DateRange&gt;(KotlinLocalDateColumnType()) {
                    override fun sqlType(): String = &quot;DATERANGE&quot;

                    override fun List&lt;String&gt;.toRange(): DateRange {
                        val endInclusive = LocalDate.parse(last()).minus(1, DateTimeUnit.DAY)
                        return DateRange(LocalDate.parse(first()), endInclusive)
                    }
                }

                fun Table.dateRange(name: String): Column&lt;DateRange&gt; = registerColumn(name, DateRangeColumnType())
            </div><p id="-yo0vxf_237">These new column types can be used in a table definition:</p><div class="code-block" data-lang="kotlin">
                object TestTable : Table(&quot;test_table&quot;) {
                    val amounts = intRange(&quot;amounts&quot;).default(1..10)
                    val holidays = dateRange(&quot;holidays&quot;)
                }
            </div><p id="-yo0vxf_239">With the addition of some custom functions, the stored data can then be queried to return the upper bound of the date range for all records that have an integer range within the specified bounds:</p><div class="code-block" data-lang="kotlin">
                transaction {
                    val holidayEnd = TestTable.holidays.upperBound()
                    TestTable
                        .select(holidayEnd)
                        .where { TestTable.amounts isContainedBy 0..100 }
                        .toList()
                }

                fun &lt;T : Comparable&lt;T&gt;, CR : ClosedRange&lt;T&gt;, R : CR?&gt; ExpressionWithColumnType&lt;R&gt;.upperBound() =
                    CustomFunction(&quot;UPPER&quot;, (columnType as RangeColumnType&lt;T, CR&gt;).subType, this)

                infix fun &lt;R : ClosedRange&lt;*&gt;?&gt; ExpressionWithColumnType&lt;R&gt;.isContainedBy(other: R) =
                    RangeIsContainedOp(this, wrap(other))

                class RangeIsContainedOp&lt;R : ClosedRange&lt;*&gt;?&gt;(
                    left: Expression&lt;R&gt;,
                    right: Expression&lt;R&gt;
                ) : ComparisonOp(left, right, &quot;&lt;@&quot;)
            </div></section><section class="chapter"><h3 id="predefined-string-data" data-toc="predefined-string-data">Predefined string data</h3><p id="-yo0vxf_241">MySQL and MariaDB provide a data type, <a href="https://dev.mysql.com/doc/refman/8.4/en/set.html" id="-yo0vxf_242" data-external="true" rel="noopener noreferrer"><code class="code" id="-yo0vxf_243">SET</code></a>, for strings that can have zero or more values from a defined list of permitted values. This could be useful, for example, when storing a list of Kotlin enum constants.</p><p id="-yo0vxf_244">To use this type, a new <code class="code" id="-yo0vxf_245">ColumnType</code> could be implemented with all the necessary overrides. This example instead takes advantage of the existing logic in <code class="code" id="-yo0vxf_246">StringColumnType</code> as the base for database storage, then uses a custom <code class="code" id="-yo0vxf_247">ColumnTransformer</code> to achieve the final transformation between a set of enum constants and a string:</p><div class="code-block" data-lang="kotlin">
                class SetColumnType&lt;T : Enum&lt;T&gt;&gt;(
                    private val enumClass: KClass&lt;T&gt;
                ) : StringColumnType() {
                    // uses reflection to retrieve elements of the enum class
                    private val enumConstants by lazy {
                        enumClass.java.enumConstants?.map { it.name } ?: emptyList()
                    }

                    override fun sqlType(): String = enumConstants
                        .takeUnless { it.isEmpty() }
                        ?.let { &quot;SET(${it.joinToString { e -&gt; &quot;'$e'&quot; }})&quot; }
                        ?: error(&quot;SET column must be defined with a list of permitted values&quot;)
                }

                inline fun &lt;reified T : Enum&lt;T&gt;&gt; Table.set(name: String): Column&lt;String&gt; =
                    registerColumn(name, SetColumnType(T::class))

                class EnumListColumnType&lt;T : Enum&lt;T&gt;&gt;(
                    private val enumClass: KClass&lt;T&gt;
                ) : ColumnTransformer&lt;String, List&lt;T&gt;&gt; {
                    private val enumConstants by lazy {
                        enumClass.java.enumConstants?.associateBy { it.name } ?: emptyMap()
                    }

                    override fun unwrap(value: List&lt;T&gt;): String {
                        return value.joinToString(separator = &quot;,&quot;) { it.name }
                    }

                    override fun wrap(value: String): List&lt;T&gt; = value
                        .takeUnless { it.isEmpty() }?.let {
                            it.split(',').map { e -&gt;
                                enumConstants[e]
                                    ?: error(&quot;$it can't be associated with any value from ${enumClass.qualifiedName}&quot;)
                            }
                        }
                        ?: emptyList()
                }
            </div><aside class="prompt" data-type="tip" data-title="" id="-yo0vxf_249"><p>See <a href="#column-transformation" id="-yo0vxf_250" data-tooltip="Column transformations allow to define custom transformations between database column types and application's data types. This can be particularly useful when you need to store data in one format but work with it in another format within your application.">column transformations</a> for more details about <code class="code" id="-yo0vxf_251">ColumnTransformer</code>.</p></aside><p id="-yo0vxf_252">The new column type and transformer can then be used in a table definition:</p><div class="code-block" data-lang="kotlin">
                enum class Vowel { A, E, I, O, U }

                object TestTable : Table(&quot;test_table&quot;) {
                    val vowel: Column&lt;List&lt;Vowel&gt;&gt; = set&lt;Vowel&gt;(&quot;vowel&quot;)
                        .transform(EnumListColumnType(Vowel::class))
                        .default(listOf(Vowel.A, Vowel.E))
                }
            </div><p id="-yo0vxf_254">Lists of enum constants can then be inserted and queried from the <code class="code" id="-yo0vxf_255">set</code> column. The following block shows a query for all records that have <code class="code" id="-yo0vxf_256">Vowel.O</code> stored at any position in the <code class="code" id="-yo0vxf_257">set</code> column string:</p><div class="code-block" data-lang="kotlin">
                transaction {
                    TestTable.insert { it[vowel] = listOf(Vowel.U, Vowel.E) }
                    TestTable.insert { it[vowel] = emptyList() }
                    TestTable.insert { it[vowel] = Vowel.entries }

                    TestTable
                        .selectAll()
                        .where { TestTable.vowel.findInSet(Vowel.O) greater 0 }
                        .toList()
                }

                fun &lt;T : Enum&lt;T&gt;&gt; Expression&lt;List&lt;T&gt;&gt;.findInSet(enum: T) =
                    CustomFunction(&quot;FIND_IN_SET&quot;, IntegerColumnType(), stringParam(enum.name), this)
            </div></section><section class="chapter"><h3 id="key-value-pair-data" data-toc="key-value-pair-data">Key-Value pair data</h3><p id="-yo0vxf_259">PostgreSQL provides a data type, <a href="https://www.postgresql.org/docs/16/hstore.html" id="-yo0vxf_260" data-external="true" rel="noopener noreferrer"><code class="code" id="-yo0vxf_261">hstore</code></a>, to store key-value data pairs in a single text string.</p><p id="-yo0vxf_262">The existing <code class="code" id="-yo0vxf_263">StringColumnType</code> class can be extended with a few overrides:</p><div class="code-block" data-lang="kotlin">
                import org.postgresql.util.PGobject

                class HStoreColumnType : TextColumnType() {
                    override fun sqlType(): String = &quot;HSTORE&quot;

                    override fun setParameter(stmt: PreparedStatementApi, index: Int, value: Any?) {
                        val parameterValue: PGobject? = value?.let {
                            PGobject().apply {
                                type = sqlType()
                                this.value = value as? String
                            }
                        }
                        super.setParameter(stmt, index, parameterValue)
                    }
                }
            </div><p id="-yo0vxf_265">A table extension function can then be added to register a new column with this type. This example assumes that the input values will be of type <code class="code" id="-yo0vxf_266">Map&lt;String, String&gt;</code>, so <code class="code" id="-yo0vxf_267">transform()</code> is used on the string column to handle parsing:</p><div class="code-block" data-lang="kotlin">
                fun Table.hstore(name: String): Column&lt;String&gt; = registerColumn(name, HStoreColumnType())

                object TestTable : Table(&quot;test_table&quot;) {
                    val bookDetails = hstore(&quot;book_details&quot;).transform(
                        wrap = {
                            it.trim('{', '}').split(&quot;, &quot;)
                                .associate { pair -&gt;
                                    pair.substringBefore(&quot;=&quot;) to pair.substringAfter(&quot;=&quot;)
                                }
                        },
                        unwrap = {
                            it.entries.joinToString(separator = &quot;,&quot;) { (k, v) -&gt;
                                &quot;\&quot;$k\&quot;=&gt;\&quot;$v\&quot;&quot;
                            }
                        }
                    )
                }
            </div><aside class="prompt" data-type="tip" data-title="" id="-yo0vxf_269"><p>See <a href="#column-transformation" id="-yo0vxf_270" data-tooltip="Column transformations allow to define custom transformations between database column types and application's data types. This can be particularly useful when you need to store data in one format but work with it in another format within your application.">column transformations</a> for more details about <code class="code" id="-yo0vxf_271">transform()</code>.</p></aside><aside class="prompt" data-type="note" data-title="" id="-yo0vxf_272"><p>To use the <code class="code" id="-yo0vxf_273">hstore</code> data type, the extension must first be enabled in the database by running <code class="code" id="-yo0vxf_274">exec(&quot;CREATE EXTENSION hstore;&quot;)</code>.</p></aside><p id="-yo0vxf_275">Map values representing key-value pairs of strings can then be inserted and queried from the <code class="code" id="-yo0vxf_276">bookDetails</code> column. The following block queries the value associated with the <code class="code" id="-yo0vxf_277">title</code> key from all <code class="code" id="-yo0vxf_278">bookDetails</code> records:</p><div class="code-block" data-lang="kotlin">
                transaction {
                    TestTable.insert {
                        it[bookDetails] = mapOf(
                            &quot;title&quot; to &quot;Kotlin in Action&quot;,
                            &quot;edition&quot; to &quot;2&quot;
                        )
                    }

                    val bookTitle = TestTable.bookDetails.getValue(&quot;title&quot;)
                    TestTable
                        .select(bookTitle)
                        .toList()
                }

                fun &lt;T : Map&lt;String, String&gt;&gt; Expression&lt;T&gt;.getValue(key: String) =
                    CustomOperator(&quot;-&gt;&quot;, TextColumnType(), this, stringParam(key))
            </div></section><section class="chapter"><h3 id="case-insensitive-data" data-toc="case-insensitive-data">Case insensitive data</h3><p id="-yo0vxf_280">PostgreSQL provides a data type, <a href="https://www.postgresql.org/docs/16/citext.html" id="-yo0vxf_281" data-external="true" rel="noopener noreferrer"><code class="code" id="-yo0vxf_282">citext</code></a>, that represents a case-insensitive string type.</p><p id="-yo0vxf_283">The existing <code class="code" id="-yo0vxf_284">StringColumnType</code> class can be extended with a few overrides:</p><div class="code-block" data-lang="kotlin">
                import org.postgresql.util.PGobject

                class CitextColumnType(
                    colLength: Int
                ) : VarCharColumnType(colLength) {
                    override fun sqlType(): String = &quot;CITEXT&quot;

                    override fun setParameter(stmt: PreparedStatementApi, index: Int, value: Any?) {
                        val parameterValue: PGobject? = value?.let {
                            PGobject().apply {
                                type = sqlType()
                                this.value = value as? String
                            }
                        }
                        super.setParameter(stmt, index, parameterValue)
                    }
                }
            </div><p id="-yo0vxf_286">A table extension function can then be added to register a new column with this type:</p><div class="code-block" data-lang="kotlin">
                fun Table.citext(name: String, length: Int): Column&lt;String&gt; =
                    registerColumn(name, CitextColumnType(length))

                object TestTable : Table(&quot;test_table&quot;) {
                    val firstName = citext(&quot;first_name&quot;, 32)
                }
            </div><aside class="prompt" data-type="note" data-title="" id="-yo0vxf_288"><p id="-yo0vxf_289">To use the <code class="code" id="-yo0vxf_290">citext</code> data type, the extension must first be enabled in the database by running <code class="code" id="-yo0vxf_291">exec(&quot;CREATE EXTENSION citext;&quot;)</code>.</p></aside><p id="-yo0vxf_292">String values can then be inserted and queried from the <code class="code" id="-yo0vxf_293">firstName</code> column in a case-insensitive manner:</p><div class="code-block" data-lang="kotlin">
                transaction {
                    val allNames = listOf(&quot;Anna&quot;, &quot;Anya&quot;, &quot;Agna&quot;)
                    TestTable.batchInsert(allNames) { name -&gt;
                        this[TestTable.firstName] = name
                    }

                    TestTable
                        .selectAll()
                        .where { TestTable.firstName like &quot;an%&quot; }
                        .toList()
                }
            </div></section></section><section class="chapter"><h2 id="column-transformation" data-toc="column-transformation">Column transformation</h2><p id="-yo0vxf_295">Column transformations allow to define custom transformations between database column types and application's data types. This can be particularly useful when you need to store data in one format but work with it in another format within your application.</p><p id="-yo0vxf_296">Consider the following example, where we define a table to store meal times and transform these times into meal types:</p><div class="code-block" data-lang="kotlin">
            enum class Meal {
                BREAKFAST,
                LUNCH,
                DINNER
            }

            object Meals : Table() {
                val mealTime: Column&lt;Meal&gt; = time(&quot;meal_time&quot;)
                    .transform(
                        wrap = {
                            when {
                                it.hour &lt; 10 -&gt; Meal.BREAKFAST
                                it.hour &lt; 15 -&gt; Meal.LUNCH
                                else -&gt; Meal.DINNER
                            }
                        },
                        unwrap = {
                            when (it) {
                                Meal.BREAKFAST -&gt; LocalTime(8, 0)
                                Meal.LUNCH -&gt; LocalTime(12, 0)
                                Meal.DINNER -&gt; LocalTime(18, 0)
                            }
                        }
                    )
            }
        </div><p id="-yo0vxf_298">The <code class="code" id="-yo0vxf_299">transform</code> function is used to apply custom transformations to the <code class="code" id="-yo0vxf_300">mealTime</code> column:</p><ul class="list _bullet" id="-yo0vxf_301"><li class="list__item" id="-yo0vxf_302"><p>The <code class="code" id="-yo0vxf_303">wrap</code> function transforms the stored <code class="code" id="-yo0vxf_304">LocalTime</code> values into <code class="code" id="-yo0vxf_305">Meal</code> enums. It checks the hour of the stored time and returns the corresponding meal type.</p></li><li class="list__item" id="-yo0vxf_306"><p>The <code class="code" id="-yo0vxf_307">unwrap</code> function transforms <code class="code" id="-yo0vxf_308">Meal</code> enums back into <code class="code" id="-yo0vxf_309">LocalTime</code> values for storage in the database.</p></li></ul><p id="-yo0vxf_310">Transformation could be also defined as an implementation of <code class="code" id="-yo0vxf_311">ColumnTransformer</code> interface and reused among different tables:</p><div class="code-block" data-lang="kotlin">
            class MealTimeTransformer : ColumnTransformer&lt;LocalTime, Meal&gt; {
                override fun wrap(value: LocalTime): Meal = when {
                    value.hour &lt; 10 -&gt; Meal.BREAKFAST
                    value.hour &lt; 15 -&gt; Meal.LUNCH
                    else -&gt; Meal.DINNER
                }

                override fun unwrap(value: Meal): LocalTime = when (value) {
                    Meal.BREAKFAST -&gt; LocalTime(8, 0)
                    Meal.LUNCH -&gt; LocalTime(12, 0)
                    Meal.DINNER -&gt; LocalTime(18, 0)
                }
            }

            object Meals : Table() {
                val mealTime: Column&lt;Meal&gt; = time(&quot;meal_time&quot;).transform(MealTimeTransformer())
            }
        </div><section class="chapter"><h3 id="null-transform" data-toc="null-transform">Null transform</h3><p id="-yo0vxf_313">Special case is <code class="code" id="-yo0vxf_314">nullTransform()</code> method. That method applies a special transformation that allows a non-nullable database column to accept and/or return values as `null` on the client side.</p><p id="-yo0vxf_315">This transformation does not alter the column's definition in the database, which will still be <code class="code" id="-yo0vxf_316">NON NULL</code>. It enables reflecting non-null values from the database as <code class="code" id="-yo0vxf_317">null</code> in Kotlin (e.g., converting an empty string from a non-nullable text column, empty lists, negative IDs, etc., to <code class="code" id="-yo0vxf_318">null</code>).</p><div class="code-block" data-lang="kotlin">
            class MealTimeNullTransformer : ColumnTransformer&lt;LocalTime, Meal?&gt; {
                override fun wrap(value: LocalTime): Meal? = when {
                    value.hour &lt; 10 -&gt; Meal.BREAKFAST
                    value.hour &lt; 15 -&gt; Meal.LUNCH
                    else -&gt; Meal.DINNER
                }

                override fun unwrap(value: Meal?): LocalTime = when (value) {
                    Meal.BREAKFAST -&gt; LocalTime(8, 0)
                    Meal.LUNCH -&gt; LocalTime(12, 0)
                    Meal.DINNER -&gt; LocalTime(18, 0)
                    else -&gt; LocalTime(0, 0)
                }
            }

            object Meals : Table() {
                val mealTime: Column&lt;Meal?&gt; = time(&quot;meal_time&quot;).transform(MealTimeNullTransformer())
            }
        </div></section></section><div class="last-modified">Last modified: 30 October 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="working-with-tables.html" class="navigation-links__prev">Working with tables</a><a href="sql-functions.html" class="navigation-links__next">SQL Functions</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b267/app.js"></script></body></html>