<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2024-07-24T13:45:07.040095032"><title>Deep Dive into DSL | Exposed</title><script type="application/json" id="virtual-toc-data">[{"id":"overview","level":0,"title":"Overview","anchor":"#overview"},{"id":"crud-operations","level":0,"title":"CRUD operations","anchor":"#crud-operations"},{"id":"where-expression","level":0,"title":"Where expression","anchor":"#where-expression"},{"id":"conditional-where","level":0,"title":"Conditional where","anchor":"#conditional-where"},{"id":"count","level":0,"title":"Count","anchor":"#count"},{"id":"order-by","level":0,"title":"Order-by","anchor":"#order-by"},{"id":"group-by","level":0,"title":"Group-by","anchor":"#group-by"},{"id":"limit","level":0,"title":"Limit","anchor":"#limit"},{"id":"join","level":0,"title":"Join","anchor":"#join"},{"id":"union","level":0,"title":"Union","anchor":"#union"},{"id":"alias","level":0,"title":"Alias","anchor":"#alias"},{"id":"schema","level":0,"title":"Schema","anchor":"#schema"},{"id":"sequence","level":0,"title":"Sequence","anchor":"#sequence"},{"id":"batch-insert","level":0,"title":"Batch Insert","anchor":"#batch-insert"},{"id":"insert-from-select","level":0,"title":"Insert From Select","anchor":"#insert-from-select"},{"id":"insert-or-ignore","level":0,"title":"Insert Or Ignore","anchor":"#insert-or-ignore"},{"id":"insert-or-update","level":0,"title":"Insert Or Update","anchor":"#insert-or-update"},{"id":"replace","level":0,"title":"Replace","anchor":"#replace"},{"id":"column-transformation","level":0,"title":"Column transformation","anchor":"#column-transformation"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b267/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Deep Dive into DSL | Exposed"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Exposed Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/docs/0.52.0/deep-dive-into-dsl.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Deep Dive into DSL | Exposed"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/docs/0.52.0/deep-dive-into-dsl.html#webpage",
    "url": "writerside-documentation/docs/0.52.0/deep-dive-into-dsl.html",
    "name": "Deep Dive into DSL | Exposed",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/docs/#website",
    "url": "writerside-documentation/docs/",
    "name": "Exposed Help"
}</script><!-- End Schema.org --></head><body data-id="Deep-Dive-into-DSL" data-main-title="Deep Dive into DSL" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs=""><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Exposed 0.52.0 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Deep-Dive-into-DSL" id="Deep-Dive-into-DSL.md">Deep Dive into DSL</h1><section class="chapter"><h2 id="overview" data-toc="overview">Overview</h2><p id="-b8qlxx_2">The DSL (Domain-Specific Language) API of Exposed is similar to actual SQL statements, but with the type safety that Kotlin offers.</p><p id="-b8qlxx_3">A database table is represented by an <code class="code" id="-b8qlxx_4">object</code> inherited from <code class="code" id="-b8qlxx_5">org.jetbrains.exposed.sql.Table</code> like this:</p><div class="code-block" data-lang="kotlin">
object StarWarsFilms : Table() {
    val id: Column&lt;Int&gt; = integer(&quot;id&quot;).autoIncrement()
    val sequelId: Column&lt;Int&gt; = integer(&quot;sequel_id&quot;).uniqueIndex()
    val name: Column&lt;String&gt; = varchar(&quot;name&quot;, 50)
    val director: Column&lt;String&gt; = varchar(&quot;director&quot;, 50)
    override val primaryKey = PrimaryKey(id, name = &quot;PK_StarWarsFilms_Id&quot;) // PK_StarWarsFilms_Id is optional here
}
</div><p id="-b8qlxx_7">Tables that contains <code class="code" id="-b8qlxx_8">Int</code> id with the name <code class="code" id="-b8qlxx_9">id</code> can be declared like this:</p><div class="code-block" data-lang="kotlin">
object StarWarsFilms : IntIdTable() {
    val sequelId: Column&lt;Int&gt; = integer(&quot;sequel_id&quot;).uniqueIndex()
    val name: Column&lt;String&gt; = varchar(&quot;name&quot;, 50)
    val director: Column&lt;String&gt; = varchar(&quot;director&quot;, 50)
}
</div></section><section class="chapter"><h2 id="crud-operations" data-toc="crud-operations">CRUD operations</h2><p id="-b8qlxx_11">CRUD stands for Create Read Update Delete, which are four basic operations for a database to support. This section shows how to perform SQL CRUD operations using Kotlin DSL.</p><section class="chapter"><h3 id="create" data-toc="create">Create</h3><p id="-b8qlxx_12">To create a new table row, you use the <code class="code" id="-b8qlxx_13">insert</code> query. Exposed provides several functions to insert rows into a table:</p><ul class="list _bullet" id="-b8qlxx_14"><li class="list__item" id="-b8qlxx_15"><p id="-b8qlxx_16"><code class="code" id="-b8qlxx_17">insert</code> adds a new row. If the same row already exists in the table, it throws an exception.</p><div class="code-block" data-lang="kotlin">
// SQL: INSERT INTO CITIES (COUNTRY, &quot;NAME&quot;, POPULATION)
// VALUES ('RUSSIA', 'St. Petersburg', 300)
Cities.insert {
    it[name] = &quot;St. Petersburg&quot;
    it[country] = Country.RUSSIA
    it[population] = 500
}
</div></li><li class="list__item" id="-b8qlxx_19"><p id="-b8qlxx_20"><code class="code" id="-b8qlxx_21">insertAndGetId</code> adds a new row and returns its ID. If the same row already exists in the table, it throws an exception. Works only with IntIdTable() tables.</p><div class="code-block" data-lang="kotlin">
// SQL: INSERT INTO CITIES (COUNTRY, &quot;NAME&quot;, POPULATION)
// VALUES ('RUSSIA', 'St. Petersburg', 300)
val id = Cities.insertAndGetId {
    it[name] = &quot;St. Petersburg&quot;
    it[country] = Country.RUSSIA
    it[population] = 500
}
</div></li><li class="list__item" id="-b8qlxx_23"><p id="-b8qlxx_24"><code class="code" id="-b8qlxx_25">insertIgnore</code> adds a new row. If the same row already exists in the table, it ignores it and doesn't throw an exception. This function is supported only for MySQL, PostgreSQL, and SQLite.</p><div class="code-block" data-lang="kotlin">
// SQL: INSERT IGNORE INTO CITIES (COUNTRY, &quot;NAME&quot;, POPULATION)
// VALUES ('RUSSIA', 'St. Petersburg', 300)
Cities.insertIgnore {
    it[name] = &quot;St. Petersburg&quot;
    it[country] = Country.RUSSIA
    it[population] = 500
}
</div></li><li class="list__item" id="-b8qlxx_27"><p id="-b8qlxx_28"><code class="code" id="-b8qlxx_29">insertIgnoreAndGetId</code> adds a new row and returns its ID. If the same row already exists in the table, it ignores it and doesn't throw an exception. This function is supported only for MySQL, PostgreSQL, and SQLite. Works only with <code class="code" id="-b8qlxx_30">IntIdTable()</code> tables.</p><div class="code-block" data-lang="kotlin">
// SQL: INSERT IGNORE INTO CITIES (COUNTRY, &quot;NAME&quot;, POPULATION)
// VALUES ('RUSSIA', 'St. Petersburg', 300)
val id = Cities.insertIgnoreAndGetId {
    it[name] = &quot;St. Petersburg&quot;
    it[country] = Country.RUSSIA
    it[population] = 500
}
</div></li></ul><p id="-b8qlxx_32">Some databases return a count of the number of rows inserted, updated, or deleted by the CRUD operation. For <code class="code" id="-b8qlxx_33">insert()</code>, <code class="code" id="-b8qlxx_34">upsert()</code>, and <code class="code" id="-b8qlxx_35">replace()</code>, this value can be accessed using the statement class property, <code class="code" id="-b8qlxx_36">insertedCount</code>:</p><div class="code-block" data-lang="kotlin">
val insertStatement = StarWarsFilms.insertIgnore {
     it[name] = &quot;The Last Jedi&quot;
    it[sequelId] = 8
    it[director] = &quot;Rian Johnson&quot;
}
val rowCount: Int = insertStatement.insertedCount
</div></section><section class="chapter"><h3 id="read" data-toc="read">Read</h3><div class="code-block" data-lang="kotlin">
val query: Query = StarWarsFilms.selectAll().where { StarWarsFilms.sequelId eq 8 }
</div><p id="-b8qlxx_39"><code class="code" id="-b8qlxx_40">Query</code> inherit <code class="code" id="-b8qlxx_41">Iterable</code> so it is possible to traverse it with map/foreach etc'. For example:</p><div class="code-block" data-lang="kotlin">
StarWarsFilms.selectAll().where { StarWarsFilms.sequelId eq 8 }.forEach {
    println(it[StarWarsFilms.name])
}
</div><p id="-b8qlxx_43">There is <code class="code" id="-b8qlxx_44">select</code> function which allows you to select specific columns or/and expressions.</p><div class="code-block" data-lang="kotlin">
val filmAndDirector = StarWarsFilms.select(StarWarsFilms.name, StarWarsFilms.director).map {
    it[StarWarsFilms.name] to it[StarWarsFilms.director]
}
</div><p id="-b8qlxx_46">If you want to select only distinct value then use <code class="code" id="-b8qlxx_47">withDistinct()</code> function:</p><div class="code-block" data-lang="kotlin">
val directors = StarWarsFilms.select(StarWarsFilms.director).where { StarWarsFilms.sequelId less 5 }.withDistinct().map {
    it[StarWarsFilms.director]
}
</div></section><section class="chapter"><h3 id="update" data-toc="update">Update</h3><div class="code-block" data-lang="kotlin">
StarWarsFilms.update({ StarWarsFilms.sequelId eq 8 }) {
    it[StarWarsFilms.name] = &quot;Episode VIII – The Last Jedi&quot;
}
</div><p id="-b8qlxx_50">If you want to update column value with some expression like increment use <code class="code" id="-b8qlxx_51">update</code> function or setter:</p><div class="code-block" data-lang="kotlin">
StarWarsFilms.update({ StarWarsFilms.sequelId eq 8 }) {
    with(SqlExpressionBuilder) {
        it.update(StarWarsFilms.sequelId, StarWarsFilms.sequelId + 1)
        // or 
        it[StarWarsFilms.sequelId] = StarWarsFilms.sequelId + 1
    }
} 
</div><p id="-b8qlxx_53">If you want to know the number of updated rows, this value is also returned by the <code class="code" id="-b8qlxx_54">update()</code> function:</p><div class="code-block" data-lang="kotlin">
val updatedCount = StarWarsFilms.update({ StarWarsFilms.name like &quot;Episode%&quot; }) {
    it[StarWarsFilms.director] = StarWarsFilms.director.upperCase()
}
</div></section><section class="chapter"><h3 id="delete" data-toc="delete">Delete</h3><div class="code-block" data-lang="kotlin">
StarWarsFilms.deleteWhere { StarWarsFilms.sequelId eq 8 }
</div><p id="-b8qlxx_57">Delete functions also return a count of the number of deleted rows, as for Update above.</p></section><section class="chapter"><h3 id="returning-data-from-modified-rows" data-toc="returning-data-from-modified-rows">Returning Data from Modified Rows</h3><p id="-b8qlxx_58">Some databases (like PostgreSQL and SQLite) allow the return of additional data every time a row is either inserted, updated, or deleted by a CRUD operation. This can be accomplished by using <code class="code" id="-b8qlxx_59">insertReturning()</code>, <code class="code" id="-b8qlxx_60">upsertReturning()</code>, <code class="code" id="-b8qlxx_61">updateReturning()</code>, or <code class="code" id="-b8qlxx_62">deleteReturning()</code> with a list of the required table columns provided as an argument. If the latter is omitted, all table columns will be returned by default:</p><div class="code-block" data-lang="kotlin">
object Projects : Table(&quot;projects&quot;) {
    val title = varchar(&quot;title&quot;, 64)
    val budget = integer(&quot;budget&quot;)
    val created = datetime(&quot;created&quot;).defaultExpression(CurrentDateTime)
}

// returns all table columns by default
val created: LocalDateTime = Projects.insertReturning {
    it[title] = &quot;Project A&quot;
    it[budget] = 100
}.single()[Projects.created]

val updatedBudgets: List&lt;Int&gt; = Projects.updateReturning(listOf(Projects.budget)) {
    it[budget] = Projects.budget.times(5)
}.map {
    it[Projects.budget]
}
</div><aside class="prompt" data-type="note" data-title="" id="-b8qlxx_64"><p>Unlike the base variants of these CRUD operations, a <code class="code" id="-b8qlxx_65">ReturningStatement</code> behaves like a <code class="code" id="-b8qlxx_66">Query</code> by also extending <code class="code" id="-b8qlxx_67">Iterable</code>, so it will not be run by the database until the first attempt to iterate over its results.</p></aside></section></section><section class="chapter"><h2 id="where-expression" data-toc="where-expression">Where expression</h2><p id="-b8qlxx_68">Query expression (where) expects a boolean operator (ie: <code class="code" id="-b8qlxx_69">Op&lt;Boolean&gt;</code>). Allowed conditions are:</p><div class="code-block" data-lang="none">
eq - (==)
neq - (!=)
isNull()
isNotNull()
less - (&lt;)
lessEq - (&lt;=)
greater - (&gt;)
greaterEq - (&gt;=)
like - (=~)
notLike - (!~)
exists
notExists
regexp
inList
notInList
between
match (MySQL MATCH AGAINST)
isDistinctFrom (null-safe equality comparison)
isNotDistinctFrom (null-safe equality comparison)
</div><p id="-b8qlxx_71">Allowed logical conditions are:</p><div class="code-block" data-lang="none">
not
and
or
andIfNotNull
orIfNotNull
compoundAnd()
compoundOr()
</div></section><section class="chapter"><h2 id="conditional-where" data-toc="conditional-where">Conditional where</h2><p id="-b8qlxx_73">It is a rather common case to have a query with a <code class="code" id="-b8qlxx_74">where</code> clause that depends on some other code's conditions. Moreover, independent or nested conditions could make it more complicated to prepare such <code class="code" id="-b8qlxx_75">where</code> clauses. Let's imagine that we have a form on a website where a user can optionally filter &quot;Star Wars&quot; films by a director and/or a sequel. In Exposed version before 0.8.1 you had to code it like:</p><div class="code-block" data-lang="kotlin">
val condition = when {
    directorName!=null &amp;&amp; sequelId!=null -&gt;
        Op.build { StarWarsFilms.director eq directorName and (StarWarsFilms.sequelId eq sequelId) }
    directorName!=null -&gt;
        Op.build { StarWarsFilms.director eq directorName }
    sequelId!=null -&gt;
        Op.build { StarWarsFilms.sequelId eq sequelId }
    else -&gt; null
}
val query = condition?.let { StarWarsFilms.selectAll().where(condition) } ?: StarWarsFilms.selectAll()
</div><p id="-b8qlxx_77">or</p><div class="code-block" data-lang="kotlin">
val query = when {
    directorName!=null &amp;&amp; sequelId!=null -&gt;
        StarWarsFilms.selectAll().where { StarWarsFilms.director eq directorName and (StarWarsFilms.sequelId eq sequelId) }
    directorName!=null -&gt;
        StarWarsFilms.selectAll().where { StarWarsFilms.director eq directorName }
    sequelId!=null -&gt;
        StarWarsFilms.selectAll().where { StarWarsFilms.sequelId eq sequelId }
    else -&gt; StarWarsFilms.selectAll()
}
</div><p id="-b8qlxx_79">This is a very primitive example, but you should get the main idea about the problem. Now let's try to write the same query in a more simple way (<code class="code" id="-b8qlxx_80">andWhere</code> function available since 0.10.5):</p><div class="code-block" data-lang="kotlin">
val query = StarWarsFilms.selectAll()
directorName?.let {
    query.andWhere { StarWarsFilms.director eq it }
}
sequelId?.let {
    query.andWhere { StarWarsFilms.sequelId eq it }
}
</div><p id="-b8qlxx_82">But what if we want to conditionally select from another table and join it only when a condition is true? You have to use <code class="code" id="-b8qlxx_83">adjustColumnSet</code> and <code class="code" id="-b8qlxx_84">adjustSelect</code> functions, which allow to extend and modify <code class="code" id="-b8qlxx_85">join</code> and <code class="code" id="-b8qlxx_86">select</code> parts of a query (see kdoc on that functions):</p><div class="code-block" data-lang="kotlin">
actorName?.let {
    query.adjustColumnSet { innerJoin(Actors, { StarWarsFilms.sequelId }, { Actors.sequelId }) }
        .adjustSelect { select(fields + Actors.columns).set }
        .andWhere { Actors.name eq actorName }
}
</div><section class="chapter"><h3 id="check-for-a-match-in-a-pattern" data-toc="check-for-a-match-in-a-pattern">Check for a match in a pattern</h3><div class="code-block" data-lang="kotlin">
StarWarsFilms.selectAll().where { StarWarsFilms.name like &quot;The %&quot; }
</div><p id="-b8qlxx_89"><code class="code" id="-b8qlxx_90">notLike</code> is also available to check for expressions that do not match the provided pattern.</p><p id="-b8qlxx_91">To perform a pattern match that supports regular expressions, use <code class="code" id="-b8qlxx_92">regexp</code> instead:</p><div class="code-block" data-lang="kotlin">
StarWarsFilms.selectAll().where { StarWarsFilms.name regexp &quot;^The(\\s\\w+){2}\$&quot; }
</div></section><section class="chapter"><h3 id="check-for-a-match-in-a-range" data-toc="check-for-a-match-in-a-range">Check for a match in a range</h3><div class="code-block" data-lang="kotlin">
StarWarsFilms.selectAll().where { StarWarsFilms.sequelId.between(4, 6) }
</div><p id="-b8qlxx_95">The <code class="code" id="-b8qlxx_96">between</code> operator returns <code class="code" id="-b8qlxx_97">true</code> if the expression is between the lower and upper range values (inclusive). Date and time values are also supported as arguments.</p></section><section class="chapter"><h3 id="check-for-a-match-in-a-collection" data-toc="check-for-a-match-in-a-collection">Check for a match in a collection</h3><div class="code-block" data-lang="kotlin">
StarWarsFilms.selectAll().where { StarWarsFilms.sequelId inList listOf(6, 4) }
</div><p id="-b8qlxx_99"><code class="code" id="-b8qlxx_100">inList</code> also accepts multiple expressions to check for equality, either as a <code class="code" id="-b8qlxx_101">Pair</code> or a <code class="code" id="-b8qlxx_102">Triple</code>:</p><div class="code-block" data-lang="kotlin">
val topRated = listOf(5 to &quot;Empire Strikes Back&quot;, 4 to &quot;A New Hope&quot;)
StarWarsFilms.selectAll().where {
    StarWarsFilms.sequelId to StarWarsFilms.name inList topRated
}
</div><p id="-b8qlxx_104"><code class="code" id="-b8qlxx_105">notInList</code> is available to check for expressions that are not equal to any elements in the provided collection.</p><p id="-b8qlxx_106">In addition to the <code class="code" id="-b8qlxx_107">IN</code> operator, the <code class="code" id="-b8qlxx_108">ANY</code> and <code class="code" id="-b8qlxx_109">ALL</code> operators are available with any preceding comparison operator:</p><div class="code-block" data-lang="kotlin">
StarWarsFilms.selectAll().where { StarWarsFilms.sequelId eq anyFrom(arrayOf(6, 4)) }
</div><p id="-b8qlxx_111"><code class="code" id="-b8qlxx_112">anyFrom()</code> and <code class="code" id="-b8qlxx_113">allFrom()</code> also accept subqueries, tables, and array expressions as arguments.</p></section></section><section class="chapter"><h2 id="count" data-toc="count">Count</h2><p id="-b8qlxx_114"><code class="code" id="-b8qlxx_115">count()</code> is a method of <code class="code" id="-b8qlxx_116">Query</code> that is used like in the example below:</p><div class="code-block" data-lang="kotlin">
val count = StarWarsFilms.selectAll().where { StarWarsFilms.sequelId eq 8 }.count()
</div></section><section class="chapter"><h2 id="order-by" data-toc="order-by">Order-by</h2><p id="-b8qlxx_118">Order-by accepts a list of columns mapped to boolean indicates if sorting should be ascending or descending. Example:</p><div class="code-block" data-lang="kotlin">
StarWarsFilms.selectAll().orderBy(StarWarsFilms.sequelId to SortOrder.ASC)
</div></section><section class="chapter"><h2 id="group-by" data-toc="group-by">Group-by</h2><p id="-b8qlxx_120">In group-by, define fields and their functions (such as <code class="code" id="-b8qlxx_121">count</code>) by the <code class="code" id="-b8qlxx_122">select()</code> method.</p><div class="code-block" data-lang="kotlin">
StarWarsFilms
    .select(StarWarsFilms.sequelId.count(), StarWarsFilms.director)
    .groupBy(StarWarsFilms.director)
</div><p id="-b8qlxx_124">Available functions are:</p><div class="code-block" data-lang="none">
count
sum
max
min
average
...
</div></section><section class="chapter"><h2 id="limit" data-toc="limit">Limit</h2><p id="-b8qlxx_126">You can use limit function to prevent loading large data sets or use it for pagination with second <code class="code" id="-b8qlxx_127">offset</code> parameter.</p><div class="code-block" data-lang="kotlin">
// Take 2 films after the first one.
StarWarsFilms.selectAll().where { StarWarsFilms.sequelId eq Actors.sequelId }.limit(2, offset = 1)
</div></section><section class="chapter"><h2 id="join" data-toc="join">Join</h2><p id="-b8qlxx_129">For the join examples below, consider the following tables:</p><div class="code-block" data-lang="kotlin">
object StarWarsFilms : IntIdTable() {
    val sequelId: Column&lt;Int&gt; = integer(&quot;sequel_id&quot;).uniqueIndex()
    val name: Column&lt;String&gt; = varchar(&quot;name&quot;, 50)
    val director: Column&lt;String&gt; = varchar(&quot;director&quot;, 50)
}
object Actors : IntIdTable() {
    val sequelId: Column&lt;Int&gt; = integer(&quot;sequel_id&quot;).uniqueIndex()
    val name: Column&lt;String&gt; = varchar(&quot;name&quot;, 50)
}
object Roles : Table() {
    val sequelId: Column&lt;Int&gt; = integer(&quot;sequel_id&quot;)
    val actorId: Column&lt;EntityID&lt;Int&gt;&gt; = reference(&quot;actor_id&quot;, Actors)
    val characterName: Column&lt;String&gt; = varchar(&quot;name&quot;, 50)
}
</div><p id="-b8qlxx_131">Join to count how many actors star in each movie:</p><div class="code-block" data-lang="kotlin">
Actors.join(StarWarsFilms, JoinType.INNER, onColumn = Actors.sequelId, otherColumn = StarWarsFilms.sequelId)
    .select(Actors.name.count(), StarWarsFilms.name)
    .groupBy(StarWarsFilms.name)
</div><p id="-b8qlxx_133">Instead of specifying <code class="code" id="-b8qlxx_134">onColumn</code> and <code class="code" id="-b8qlxx_135">otherColumn</code>, <code class="code" id="-b8qlxx_136">additionalConstraint</code> can be used (and allows specifying other types of join conditions).</p><div class="code-block" data-lang="kotlin">
Actors.join(StarWarsFilms, JoinType.INNER, additionalConstraint = { StarWarsFilms.sequelId eq Actors.sequelId })
    .select(Actors.name.count(), StarWarsFilms.name)
    .groupBy(StarWarsFilms.name)
</div><p id="-b8qlxx_138">When joining on a foreign key, the more concise <code class="code" id="-b8qlxx_139">innerJoin</code> can be used:</p><div class="code-block" data-lang="kotlin">
(Actors innerJoin Roles)
    .select(Roles.characterName.count(), Actors.name)
    .groupBy(Actors.name)
    .toList()
</div><p id="-b8qlxx_141">This is equivalent to the following:</p><div class="code-block" data-lang="kotlin">
Actors.join(Roles, JoinType.INNER, onColumn = Actors.id, otherColumn = Roles.actorId)
    .select(Roles.characterName.count(), Actors.name)
    .groupBy(Actors.name)
    .toList()
</div></section><section class="chapter"><h2 id="union" data-toc="union">Union</h2><p id="-b8qlxx_143">You can combine the results of multiple queries using <code class="code" id="-b8qlxx_144">.union(...)</code>. Per the SQL specification, the queries must have the same number of columns, and not be marked for update. Subqueries may be combined when supported by the database.</p><div class="code-block" data-lang="kotlin">
val lucasDirectedQuery = StarWarsFilms.select(StarWarsFilms.name).where { StarWarsFilms.director eq &quot;George Lucas&quot; }
val abramsDirectedQuery = StarWarsFilms.select(StarWarsFilms.name).where { StarWarsFilms.director eq &quot;J.J. Abrams&quot; }
val filmNames = lucasDirectedQuery.union(abramsDirectedQuery).map { it[StarWarsFilms.name] }
</div><p id="-b8qlxx_146">Only unique rows are returned by default. Duplicates may be returned using <code class="code" id="-b8qlxx_147">.unionAll()</code>.</p><div class="code-block" data-lang="kotlin">
val lucasDirectedQuery = StarWarsFilms.select(StarWarsFilms.name).where { StarWarsFilms.director eq &quot;George Lucas&quot; }
val originalTrilogyQuery = StarWarsFilms.select(StarWarsFilms.name).where { StarWarsFilms.sequelId inList (3..5) }
val filmNames = lucasDirectedQuery.unionAll(originalTrilogyQuery).map { it[StarWarsFilms.name] }
</div></section><section class="chapter"><h2 id="alias" data-toc="alias">Alias</h2><p id="-b8qlxx_149">Aliases allow preventing ambiguity between field names and table names. Use the aliased var instead of original one:</p><div class="code-block" data-lang="kotlin">
val filmTable1 = StarWarsFilms.alias(&quot;ft1&quot;)
filmTable1.selectAll() // can be used in joins etc'
</div><p id="-b8qlxx_151">Also, aliases allow you to use the same table in a join multiple times:</p><div class="code-block" data-lang="kotlin">
val sequelTable = StarWarsFilms.alias(&quot;sql&quot;)
val originalAndSequelNames = StarWarsFilms
    .innerJoin(sequelTable, { StarWarsFilms.sequelId }, { sequelTable[StarWarsFilms.id] })
    .select(StarWarsFilms.name, sequelTable[StarWarsFilms.name])
    .map { it[StarWarsFilms.name] to it[sequelTable[StarWarsFilms.name]] }
</div><p id="-b8qlxx_153">And they can be used when selecting from sub-queries:</p><div class="code-block" data-lang="kotlin">
val starWarsFilms = StarWarsFilms
    .select(StarWarsFilms.id, StarWarsFilms.name)
    .alias(&quot;swf&quot;)
val id = starWarsFilms[StarWarsFilms.id]
val name = starWarsFilms[StarWarsFilms.name]
starWarsFilms
    .select(id, name)
    .map { it[id] to it[name] }
</div></section><section class="chapter"><h2 id="schema" data-toc="schema">Schema</h2><p id="-b8qlxx_155">You can create a schema or drop an existing one:</p><div class="code-block" data-lang="kotlin">
val schema = Schema(&quot;my_schema&quot;) // my_schema is the schema name.
// Creates a Schema
SchemaUtils.createSchema(schema)
// Drops a Schema
SchemaUtils.dropSchema(schema)
</div><p id="-b8qlxx_157">Also, you can specify the schema owner like this (some databases require the explicit owner) :</p><div class="code-block" data-lang="kotlin">
val schema = Schema(&quot;my_schema&quot;, authorization = &quot;owner&quot;)
</div><p id="-b8qlxx_159">If you have many schemas and you want to set a default one, you can use:</p><div class="code-block" data-lang="kotlin">
SchemaUtils.setSchema(schema)
</div></section><section class="chapter"><h2 id="sequence" data-toc="sequence">Sequence</h2><p id="-b8qlxx_161">If you want to use Sequence, Exposed allows you to:</p><section class="chapter"><h3 id="define-a-sequence" data-toc="define-a-sequence">Define a Sequence</h3><div class="code-block" data-lang="kotlin">
val myseq = Sequence(&quot;my_sequence&quot;) // my_sequence is the sequence name.
</div><p id="-b8qlxx_163">Several parameters can be specified to control the properties of the sequence:</p><div class="code-block" data-lang="kotlin">
private val myseq = Sequence(
    name = &quot;my_sequence&quot;,
    startWith = 4,
    incrementBy = 2,
    minValue = 1,
    maxValue = 10,
    cycle = true,
    cache = 20
)
</div></section><section class="chapter"><h3 id="create-and-drop-a-sequence" data-toc="create-and-drop-a-sequence">Create and Drop a Sequence</h3><div class="code-block" data-lang="kotlin">
// Creates a sequence
SchemaUtils.createSequence(myseq)
// Drops a sequence
SchemaUtils.dropSequence(myseq)
</div></section><section class="chapter"><h3 id="use-the-nextval-function" data-toc="use-the-nextval-function">Use the NextVal function</h3><p id="-b8qlxx_166">You can use the nextVal function like this:</p><div class="code-block" data-lang="kotlin">
val nextVal = myseq.nextVal()
val id = StarWarsFilms.insertAndGetId {
    it[id] = nextVal
    it[name] = &quot;The Last Jedi&quot;
    it[sequelId] = 8
    it[director] = &quot;Rian Johnson&quot;
}
</div><div class="code-block" data-lang="kotlin">
val firstValue = StarWarsFilms.select(nextVal).single()[nextVal]
</div></section></section><section class="chapter"><h2 id="batch-insert" data-toc="batch-insert">Batch Insert</h2><p id="-b8qlxx_169">Batch Insert allow mapping a list of entities into DB raws in one sql statement. It is more efficient than inserting one by one as it initiates only one statement. Here is an example that uses a simple list:</p><div class="code-block" data-lang="kotlin">
val cityNames = listOf(&quot;Paris&quot;, &quot;Moscow&quot;, &quot;Helsinki&quot;)
val allCitiesID = cities.batchInsert(cityNames) { name -&gt;
    this[cities.name] = name
}
</div><p id="-b8qlxx_171">Here is an example that uses a list of data class instances:</p><div class="code-block" data-lang="kotlin">
data class SWFilmData(val sequelId: Int, val name: String, val director: String)

transaction {
    // ...
    val films = listOf(
        SWFilmData(5, &quot;The Empire Strikes Back&quot;, &quot;Irvin Kershner&quot;),
        SWFilmData(4, &quot;A New Hope&quot;, &quot;George Lucas&quot;),
        SWFilmData(7, &quot;The Force Awakens&quot;, &quot;JJ Abrams&quot;)
    )

    StarWarsFilms.batchInsert(films) { (id, name, director) -&gt;
        this[StarWarsFilms.sequelId] = id
        this[StarWarsFilms.name] = name
        this[StarWarsFilms.director] = director
    }

    StarWarsFilms.selectAll().count() // 3
}
</div><aside class="prompt" data-type="note" data-title="" id="-b8qlxx_173"><p>The `batchInsert` function will still create multiple `INSERT` statements when interacting with your database. </p><p id="-b8qlxx_174">You most likely want to couple this with the <code class="code" id="-b8qlxx_175">rewriteBatchedInserts=true</code> (or <code class="code" id="-b8qlxx_176">rewriteBatchedStatements=true</code>) option of your relevant JDBC driver, which will convert those into a single bulkInsert.</p><p id="-b8qlxx_177">You can find the documentation for this option for MySQL <a href="https://dev.mysql.com/doc/connector-j/en/connector-j-connp-props-performance-extensions.html#cj-conn-prop_rewriteBatchedStatements" id="-b8qlxx_178" data-external="true" rel="noopener noreferrer">here</a> and PostgresSQL <a href="https://jdbc.postgresql.org/documentation/use/" id="-b8qlxx_179" data-external="true" rel="noopener noreferrer">here</a>.</p></aside><p id="-b8qlxx_180">If you don't need to get the newly generated values (example: auto incremented ID), set the <code class="code" id="-b8qlxx_181">shouldReturnGeneratedValues</code> parameter to false, this increases the performance of batch inserts by batching them in chunks, instead of always waiting for the database to synchronize the newly inserted object state.</p><p id="-b8qlxx_182">If you want to check if the <code class="code" id="-b8qlxx_183">rewriteBatchedInserts</code> + <code class="code" id="-b8qlxx_184">batchInsert</code> is working correctly, check how to enable JDBC logging for your driver because Exposed will always show the non-rewritten multiple inserts. You can find the documentation for how to enable logging in PostgresSQL <a href="https://jdbc.postgresql.org/documentation/logging/" id="-b8qlxx_185" data-external="true" rel="noopener noreferrer">here</a>.</p></section><section class="chapter"><h2 id="insert-from-select" data-toc="insert-from-select">Insert From Select</h2><p id="-b8qlxx_186">If you want to use <code class="code" id="-b8qlxx_187">INSERT INTO ... SELECT</code> SQL clause try Exposed analog <code class="code" id="-b8qlxx_188">Table.insert(Query)</code>.</p><div class="code-block" data-lang="kotlin">
val substring = users.name.substring(1, 2)
cities.insert(users.select(substring).orderBy(users.id).limit(2))
</div><p id="-b8qlxx_190">By default it will try to insert into all non auto-increment <code class="code" id="-b8qlxx_191">Table</code> columns in order they defined in Table instance. If you want to specify columns or change the order, provide list of columns as second parameter:</p><div class="code-block" data-lang="kotlin">
val userCount = users.selectAll().count()
users.insert(users.select(stringParam(&quot;Foo&quot;), Random().castTo&lt;String&gt;(VarCharColumnType()).substring(1, 10)), columns = listOf(users.name, users.id))
</div></section><section class="chapter"><h2 id="insert-or-ignore" data-toc="insert-or-ignore">Insert Or Ignore</h2><p id="-b8qlxx_193">If supported by your specific database, <code class="code" id="-b8qlxx_194">insertIgnore()</code> allows insert statements to be executed without throwing any ignorable errors. This may be useful, for example, when insertion conflicts are possible:</p><div class="code-block" data-lang="kotlin">
StarWarsFilms.insert {
    it[sequelId] = 8 // column pre-defined with a unique index
    it[name] = &quot;The Last Jedi&quot;
    it[director] = &quot;Rian Johnson&quot;
}
// If insert() was used, this would throw a constraint violation exception
// Instead, this new row is ignored and discarded
StarWarsFilms.insertIgnore {
    it[sequelId] = 8
    it[name] = &quot;The Rise of Skywalker&quot;
    it[director] = &quot;JJ Abrams&quot;
}
</div></section><section class="chapter"><h2 id="insert-or-update" data-toc="insert-or-update">Insert Or Update</h2><p id="-b8qlxx_196">Insert or update (Upsert) is a database operation that either inserts a new row or updates an existing row if a duplicate constraint already exists. The supported functionality of <code class="code" id="-b8qlxx_197">upsert()</code> is dependent on the specific database being used. For example, MySQL's <code class="code" id="-b8qlxx_198">INSERT ... ON DUPLICATE KEY UPDATE</code> statement automatically assesses the primary key and unique indices for a duplicate value, so using the function in Exposed would look like this:</p><div class="code-block" data-lang="kotlin">
// inserts a new row
StarWarsFilms.upsert {
    it[sequelId] = 9 // column pre-defined with a unique index
    it[name] = &quot;The Rise of Skywalker&quot;
    it[director] = &quot;Rian Johnson&quot;
}
// updates existing row with the correct [director]
StarWarsFilms.upsert {
    it[sequelId] = 9
    it[name] = &quot;The Rise of Skywalker&quot;
    it[director] = &quot;JJ Abrams&quot;
}
</div><p id="-b8qlxx_200">If none of the optional arguments are provided to <code class="code" id="-b8qlxx_201">upsert()</code>, the statements in the <code class="code" id="-b8qlxx_202">body</code> block will be used for both the insert and update parts of the operation. This means that, for example, if a table mapping has columns with default values and these columns are omitted from the <code class="code" id="-b8qlxx_203">body</code> block, the default values will be used for insertion as well as for the update operation. If the update operation should differ from the insert operation, then <code class="code" id="-b8qlxx_204">onUpdate</code> should be provided an argument with the specific columns to update, as seen in the example below.</p><p id="-b8qlxx_205">Using another example, PostgreSQL allows more control over which key constraint columns to check for conflict, whether different values should be used for an update, and whether the update statement should have a <code class="code" id="-b8qlxx_206">WHERE</code> clause:</p><div class="code-block" data-lang="kotlin">
val incrementSequelId = listOf(StarWarsFilms.sequelId to StarWarsFilms.sequelId.plus(1))
StarWarsFilms.upsert(
    StarWarsFilms.sequelId,
    onUpdate = incrementSequelId,
    where = { StarWarsFilms.director like stringLiteral(&quot;JJ%&quot;) }
) {
    it[sequelId] = 9
    it[name] = &quot;The Rise of Skywalker&quot;
    it[director] = &quot;JJ Abrams&quot;
}
</div><p id="-b8qlxx_208">If the update operation should be identical to the insert operation except for a few columns, then <code class="code" id="-b8qlxx_209">onUpdateExclude</code> should be provided an argument with the specific columns to exclude. This parameter could also be used for the reverse case when only a small subset of columns should be updated but duplicating the insert values is tedious:</p><div class="code-block" data-lang="kotlin">
// on conflict, all columns EXCEPT [director] are updated with values from the lambda block
StarWarsFilms.upsert(onUpdateExclude = listOf(StarWarsFilms.director)) {
    it[sequelId] = 9
    it[name] = &quot;The Rise of Skywalker&quot;
    it[director] = &quot;JJ Abrams&quot;
}

// on conflict, ONLY column [director] is updated with value from the lambda block
StarWarsFilms.upsert(
    onUpdateExclude = StarWarsFilms.columns - setOf(StarWarsFilms.director)
) {
    it[sequelId] = 9
    it[name] = &quot;The Rise of Skywalker&quot;
    it[director] = &quot;JJ Abrams&quot;
}
</div><p id="-b8qlxx_211">If a specific database supports user-defined key columns and none are provided, the table's primary key is used. If there is no defined primary key, the first unique index is used. If there are no unique indices, each database handles this case differently, so it is strongly advised that keys are defined to avoid unexpected results.</p><aside class="prompt" data-type="note" data-title="" id="-b8qlxx_212"><p>Databases that do not support a specific Insert or Update command implement the standard <code class="code" id="-b8qlxx_213">MERGE INTO ... USING</code> statement with aliases and a derived table column list. These include Oracle, SQL Server, and H2 compatibility modes (except for MySQL mode). Any columns defined as key constraints (to be used in the <code class="code" id="-b8qlxx_214">ON</code> clause) must be included in the statement block to avoid throwing an error.</p></aside></section><section class="chapter"><h2 id="replace" data-toc="replace">Replace</h2><p id="-b8qlxx_215">SQLite, MySQL, and MariaDB (as well as the H2 compatibility modes of the latter 2 databases) support a <code class="code" id="-b8qlxx_216">REPLACE</code> statement that acts in a similar manner to an <code class="code" id="-b8qlxx_217">INSERT OR UPDATE</code> statement. The only difference is that, if an insertion would violate a unique constraint, the existing row is deleted (not updated) before the new row is inserted.</p><div class="code-block" data-lang="kotlin">
object StarWarsFilms : Table() {
    val sequelId: Column&lt;Int&gt; = integer(&quot;sequel_id&quot;).uniqueIndex()
    val releaseYear: Column&lt;Int&gt; = integer(&quot;release_year&quot;)
    val name: Column&lt;String&gt; = varchar(&quot;name&quot;, 50)
    val director: Column&lt;String&gt; = varchar(&quot;director&quot;, 50)
    val rating: Column&lt;Double&gt; = double(&quot;rating&quot;).default(10.0)

    override val primaryKey = PrimaryKey(sequelId, releaseYear)
}

transaction {
    // ...
    // inserts a new row with default rating
    StarWarsFilms.replace {
        it[sequelId] = 9
        it[releaseYear] = 2019
        it[name] = &quot;The Rise of Skywalker&quot;
        it[director] = &quot;JJ Abrams&quot;
    }
    // deletes existing row and inserts new row with set [rating]
    StarWarsFilms.replace {
        it[sequelId] = 9
        it[releaseYear] = 2019
        it[name] = &quot;The Rise of Skywalker&quot;
        it[director] = &quot;JJ Abrams&quot;
        it[rating] = 5.2
    }
}
</div><p id="-b8qlxx_219">Unlike Insert or Update, none of the supporting databases allows a <code class="code" id="-b8qlxx_220">WHERE</code> clause. Also, the constraints used to assess a violation are limited to the primary key and unique indexes, so there is no parameter for a custom key set.</p><p id="-b8qlxx_221">The values specified in the statement block will be used for the insert statement, and any omitted columns are set to their default values, if applicable.</p><aside class="prompt" data-type="note" data-title="" id="-b8qlxx_222"><p>In the example above, if the original row was inserted with a user-defined <code class="code" id="-b8qlxx_223">rating</code>, then <code class="code" id="-b8qlxx_224">replace()</code> was executed with a block that omitted the <code class="code" id="-b8qlxx_225">rating</code> column, the newly inserted row would store the default rating value. This is because the old row was completely deleted first.</p></aside></section><section class="chapter"><h2 id="column-transformation" data-toc="column-transformation">Column transformation</h2><p id="-b8qlxx_226">Column transformations allow to define custom transformations between database column types and application's data types. This can be particularly useful when you need to store data in one format but work with it in another format within your application.</p><p id="-b8qlxx_227">Consider the following example, where we define a table to store meal times and transform these times into meal types:</p><div class="code-block" data-lang="kotlin">
enum class Meal {
    BREAKFAST,
    LUNCH,
    DINNER
}

object Meals : Table() {
    val mealTime: Column&lt;Meal&gt; = time(&quot;meal_time&quot;)
        .transform(
            wrap = {
                when {
                    it.hour &lt; 10 -&gt; Meal.BREAKFAST
                    it.hour &lt; 15 -&gt; Meal.LUNCH
                    else -&gt; Meal.DINNER
                }
            },
            unwrap = {
                when (it) {
                    Meal.BREAKFAST -&gt; LocalTime(8, 0)
                    Meal.LUNCH -&gt; LocalTime(12, 0)
                    Meal.DINNER -&gt; LocalTime(18, 0)
                }
            }
        )
}
</div><p id="-b8qlxx_229">The <code class="code" id="-b8qlxx_230">transform</code> function is used to apply custom transformations to the <code class="code" id="-b8qlxx_231">mealTime</code> column:</p><ul class="list _bullet" id="-b8qlxx_232"><li class="list__item" id="-b8qlxx_233"><p>The <code class="code" id="-b8qlxx_234">wrap</code> function transforms the stored <code class="code" id="-b8qlxx_235">LocalTime</code> values into <code class="code" id="-b8qlxx_236">Meal</code> enums. It checks the hour of the stored time and returns the corresponding meal type.</p></li><li class="list__item" id="-b8qlxx_237"><p>The <code class="code" id="-b8qlxx_238">unwrap</code> function transforms <code class="code" id="-b8qlxx_239">Meal</code> enums back into <code class="code" id="-b8qlxx_240">LocalTime</code> values for storage in the database.</p></li></ul><p id="-b8qlxx_241">Transformation could be also defined as an implementation of <code class="code" id="-b8qlxx_242">ColumnTransformer</code> interface and reused among different tables:</p><div class="code-block" data-lang="kotlin">
class MealTimeTransformer : ColumnTransformer&lt;LocalTime, Meal&gt; {
    override fun wrap(value: LocalTime): Meal = when {
        value.hour &lt; 10 -&gt; Meal.BREAKFAST
        value.hour &lt; 15 -&gt; Meal.LUNCH
        else -&gt; Meal.DINNER
    }

    override fun unwrap(value: Meal): LocalTime = when (value) {
        Meal.BREAKFAST -&gt; LocalTime(8, 0)
        Meal.LUNCH -&gt; LocalTime(12, 0)
        Meal.DINNER -&gt; LocalTime(18, 0)
    }
}

object Meals : Table() {
    val mealTime: Column&lt;Meal&gt; = time(&quot;meal_time&quot;).transform(MealTimeTransformer())
}
</div></section><div class="last-modified">Last modified: 24 July 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="transactions.html" class="navigation-links__prev">Transactions</a><a href="deep-dive-into-dao.html" class="navigation-links__next">Deep Dive into DAO</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b267/app.js"></script></body></html>