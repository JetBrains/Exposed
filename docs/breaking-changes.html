<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2024-10-30T15:56:54.88316124"><title>Breaking Changes | Exposed</title><script type="application/json" id="virtual-toc-data">[{"id":"0-56-0","level":0,"title":"0.56.0","anchor":"#0-56-0"},{"id":"0-55-0","level":0,"title":"0.55.0","anchor":"#0-55-0"},{"id":"0-54-0","level":0,"title":"0.54.0","anchor":"#0-54-0"},{"id":"0-53-0","level":0,"title":"0.53.0","anchor":"#0-53-0"},{"id":"0-51-0","level":0,"title":"0.51.0","anchor":"#0-51-0"},{"id":"0-50-0","level":0,"title":"0.50.0","anchor":"#0-50-0"},{"id":"0-49-0","level":0,"title":"0.49.0","anchor":"#0-49-0"},{"id":"0-48-0","level":0,"title":"0.48.0","anchor":"#0-48-0"},{"id":"0-47-0","level":0,"title":"0.47.0","anchor":"#0-47-0"},{"id":"0-46-0","level":0,"title":"0.46.0","anchor":"#0-46-0"},{"id":"0-44-0","level":0,"title":"0.44.0","anchor":"#0-44-0"},{"id":"0-43-0","level":0,"title":"0.43.0","anchor":"#0-43-0"},{"id":"0-42-0","level":0,"title":"0.42.0","anchor":"#0-42-0"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b267/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Breaking Changes | Exposed"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Exposed Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/docs/0.56.0/breaking-changes.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Breaking Changes | Exposed"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/docs/0.56.0/breaking-changes.html#webpage",
    "url": "writerside-documentation/docs/0.56.0/breaking-changes.html",
    "name": "Breaking Changes | Exposed",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/docs/#website",
    "url": "writerside-documentation/docs/",
    "name": "Exposed Help"
}</script><!-- End Schema.org --></head><body data-id="Breaking-Changes" data-main-title="Breaking Changes" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Releases"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Exposed 0.56.0 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Breaking-Changes" id="Breaking-Changes.md">Breaking Changes</h1><section class="chapter"><h2 id="0-56-0" data-toc="0-56-0">0.56.0</h2><ul class="list _bullet" id="dfntvj_2"><li class="list__item" id="dfntvj_3"><p id="dfntvj_4">If the <code class="code" id="dfntvj_5">distinct</code> parameter of <code class="code" id="dfntvj_6">groupConcat()</code> is set to <code class="code" id="dfntvj_7">true</code>, when using Oracle or SQL Server, this will now fail early with an <code class="code" id="dfntvj_8">UnsupportedByDialectException</code>. Previously, the setting would be ignored and SQL function generation would not include a <code class="code" id="dfntvj_9">DISTINCT</code> clause.</p></li><li class="list__item" id="dfntvj_10"><p id="dfntvj_11">In Oracle and H2 Oracle, the <code class="code" id="dfntvj_12">ubyte()</code> column now maps to data type <code class="code" id="dfntvj_13">NUMBER(3)</code> instead of <code class="code" id="dfntvj_14">NUMBER(4)</code>.</p></li><li class="list__item" id="dfntvj_15"><p id="dfntvj_16">In Oracle and H2 Oracle, the <code class="code" id="dfntvj_17">ushort()</code> column now maps to data type <code class="code" id="dfntvj_18">NUMBER(5)</code> instead of <code class="code" id="dfntvj_19">NUMBER(6)</code>.</p></li><li class="list__item" id="dfntvj_20"><p id="dfntvj_21">In Oracle and H2 Oracle, the <code class="code" id="dfntvj_22">uinteger()</code> column now maps to data type <code class="code" id="dfntvj_23">NUMBER(10)</code> instead of <code class="code" id="dfntvj_24">NUMBER(13)</code>.</p></li><li class="list__item" id="dfntvj_25"><p id="dfntvj_26">In Oracle and H2 Oracle, the <code class="code" id="dfntvj_27">integer()</code> column now maps to data type <code class="code" id="dfntvj_28">NUMBER(10)</code> and <code class="code" id="dfntvj_29">INTEGER</code> respectively, instead of <code class="code" id="dfntvj_30">NUMBER(12)</code>. In Oracle and SQLite, using the integer column in a table now also creates a CHECK constraint to ensure that no out-of-range values are inserted.</p></li><li class="list__item" id="dfntvj_31"><p id="dfntvj_32"><code class="code" id="dfntvj_33">ArrayColumnType</code> now supports multidimensional arrays and includes an additional generic parameter. If it was previously used for one-dimensional arrays with the parameter <code class="code" id="dfntvj_34">T</code> like <code class="code" id="dfntvj_35">ArrayColumnType&lt;T&gt;</code>, it should now be defined as <code class="code" id="dfntvj_36">ArrayColumnType&lt;T, List&lt;T&gt;&gt;</code>. For instance, <code class="code" id="dfntvj_37">ArrayColumnType&lt;Int&gt;</code> should now be <code class="code" id="dfntvj_38">ArrayColumnType&lt;Int, List&lt;Int&gt;&gt;</code>.</p></li><li class="list__item" id="dfntvj_39"><p id="dfntvj_40"><code class="code" id="dfntvj_41">EntityID</code> and <code class="code" id="dfntvj_42">CompositeID</code> no longer implement <code class="code" id="dfntvj_43">Comparable</code> themselves, to allow their wrapped identity values to be of a type that is not necessarily <code class="code" id="dfntvj_44">Comparable</code>, like <code class="code" id="dfntvj_45">kotlin.uuid.Uuid</code>.</p><p id="dfntvj_46">Any use of an entity's <code class="code" id="dfntvj_47">id</code> with Kotlin comparison operators or <code class="code" id="dfntvj_48">compareTo()</code> will now require that the wrapped value be used directly: <code class="code" id="dfntvj_49">entity1.id &lt; entity2.id</code> will need to become <code class="code" id="dfntvj_50">entity1.id.value &lt; entity2.id.value</code>. Any use of an entity's <code class="code" id="dfntvj_51">id</code> with an Exposed function that is also type restricted to <code class="code" id="dfntvj_52">Comparable</code> (for example, <code class="code" id="dfntvj_53">avg()</code>) will also require defining a new function. In this event, please also leave a comment on <a href="https://youtrack.jetbrains.com/issue/EXPOSED-577" id="dfntvj_54" data-external="true" rel="noopener noreferrer">YouTrack</a> with a use case so the original function signature can be potentially reassessed.</p></li></ul></section><section class="chapter"><h2 id="0-55-0" data-toc="0-55-0">0.55.0</h2><ul class="list _bullet" id="dfntvj_55"><li class="list__item" id="dfntvj_56"><p id="dfntvj_57">The <code class="code" id="dfntvj_58">DeleteStatement</code> property <code class="code" id="dfntvj_59">table</code> is now deprecated in favor of <code class="code" id="dfntvj_60">targetsSet</code>, which holds a <code class="code" id="dfntvj_61">ColumnSet</code> that may be a <code class="code" id="dfntvj_62">Table</code> or <code class="code" id="dfntvj_63">Join</code>. This enables the use of the new <code class="code" id="dfntvj_64">Join.delete()</code> function, which performs a delete operation on a specific table from the join relation. The original statement class constructor has also been deprecated in favor of the constructor that accepts <code class="code" id="dfntvj_65">targetsSet</code>, as well as another additional parameter <code class="code" id="dfntvj_66">targetTables</code> (for specifying which table from the join relation, if applicable, to delete from).</p></li><li class="list__item" id="dfntvj_67"><p id="dfntvj_68">The <code class="code" id="dfntvj_69">DeleteStatement</code> property <code class="code" id="dfntvj_70">offset</code> was not being used and is now deprecated, as are the extension functions that have an <code class="code" id="dfntvj_71">offset</code> parameter. <code class="code" id="dfntvj_72">deleteWhere()</code> and <code class="code" id="dfntvj_73">deleteIgnoreWhere()</code>, as well as the original statement class constructor, no longer accept an argument for <code class="code" id="dfntvj_74">offset</code>.</p></li><li class="list__item" id="dfntvj_75"><p id="dfntvj_76"><code class="code" id="dfntvj_77">SizedIterable.limit(n, offset)</code> is now deprecated in favor of 2 independent methods, <code class="code" id="dfntvj_78">limit()</code> and <code class="code" id="dfntvj_79">offset()</code>. In supporting databases, this allows the generation of an OFFSET clause in the SELECT statement without any LIMIT clause. Any custom implementations of the <code class="code" id="dfntvj_80">SizedIterable</code> interface with a <code class="code" id="dfntvj_81">limit()</code> override will now show a warning that the declaration overrides a deprecated member. This override should be split into an implementation of the 2 new members instead.</p><p id="dfntvj_82">The original <code class="code" id="dfntvj_83">FunctionProvider.queryLimit()</code> is also being deprecated in favor of <code class="code" id="dfntvj_84">queryLimitAndOffset()</code>, which takes a nullable <code class="code" id="dfntvj_85">size</code> parameter to allow exclusion of the LIMIT clause. This latter deprecation only affects extensions of the <code class="code" id="dfntvj_86">FunctionProvider</code> class when creating a custom <code class="code" id="dfntvj_87">VendorDialect</code> class.</p></li><li class="list__item" id="dfntvj_88"><p id="dfntvj_89">In Oracle, the <code class="code" id="dfntvj_90">short</code> column now maps to data type <code class="code" id="dfntvj_91">NUMBER(5)</code> instead of <code class="code" id="dfntvj_92">SMALLINT</code> because <code class="code" id="dfntvj_93">SMALLINT</code> is stored as <code class="code" id="dfntvj_94">NUMBER(38)</code> in the database and takes up unnecessary storage. In Oracle and SQLite, using the <code class="code" id="dfntvj_95">short</code> column in a table now also creates a check constraint to ensure that no out-of-range values are inserted.</p></li><li class="list__item" id="dfntvj_96"><p id="dfntvj_97">In Oracle, the <code class="code" id="dfntvj_98">byte</code> column now maps to data type <code class="code" id="dfntvj_99">NUMBER(3)</code> instead of <code class="code" id="dfntvj_100">SMALLINT</code> because <code class="code" id="dfntvj_101">SMALLINT</code> is stored as <code class="code" id="dfntvj_102">NUMBER(38)</code> in the database and takes up unnecessary storage. In SQL Server, the <code class="code" id="dfntvj_103">byte</code> column now maps to data type <code class="code" id="dfntvj_104">SMALLINT</code> instead of <code class="code" id="dfntvj_105">TINYINT</code> because <code class="code" id="dfntvj_106">TINYINT</code> <a href="https://learn.microsoft.com/en-us/sql/t-sql/data-types/int-bigint-smallint-and-tinyint-transact-sql?view=sql-server-ver16#:~:text=2%20bytes-,tinyint,-0%20to%20255" id="dfntvj_107" data-external="true" rel="noopener noreferrer">allows values from 0 to 255</a>. In SQL Server, SQLite, Oracle, PostgreSQL, and H2 PostgreSQL, using the <code class="code" id="dfntvj_108">byte</code> column in a table now also creates a check constraint to ensure that no out-of-range values are inserted.</p></li><li class="list__item" id="dfntvj_109"><p id="dfntvj_110">The transformation of a nullable column (<code class="code" id="dfntvj_111">Column&lt;Unwrapped?&gt;.transform()</code>) requires handling null values. This enables conversions from <code class="code" id="dfntvj_112">null</code> to a non-nullable value, and vice versa.</p></li><li class="list__item" id="dfntvj_113"><p id="dfntvj_114">In H2 the definition of json column with default value changed from <code class="code" id="dfntvj_115">myColumn JSON DEFAULT '{&quot;key&quot;: &quot;value&quot;}'</code> to <code class="code" id="dfntvj_116">myColumn JSON DEFAULT JSON '{&quot;key&quot;: &quot;value&quot;}'</code></p></li></ul></section><section class="chapter"><h2 id="0-54-0" data-toc="0-54-0">0.54.0</h2><ul class="list _bullet" id="dfntvj_117"><li class="list__item" id="dfntvj_118"><p>All objects that are part of the sealed class <code class="code" id="dfntvj_119">ForUpdateOption</code> are now converted to <code class="code" id="dfntvj_120">data object</code>.</p></li><li class="list__item" id="dfntvj_121"><p>The <code class="code" id="dfntvj_122">onUpdate</code> parameter in <code class="code" id="dfntvj_123">upsert()</code>, <code class="code" id="dfntvj_124">upsertReturning()</code>, and <code class="code" id="dfntvj_125">batchUpsert()</code> will no longer accept a list of column-value pairs as an argument. The parameter now takes a lambda block with an <code class="code" id="dfntvj_126">UpdateStatement</code> as its argument, so that column-value assignments for the UPDATE clause can be set in a similar way to <code class="code" id="dfntvj_127">update()</code>. This enables the use of <code class="code" id="dfntvj_128">insertValue(column)</code> in expressions to specify that the same value to be inserted into a column should be used when updating.</p></li></ul><div class="code-block" data-lang="kotlin">
// before
TestTable.upsert(
    onUpdate = listOf(Words.count to Words.count.plus(1))
) {
    it[word] = &quot;Kotlin&quot;
    it[count] = 3
}

// after
TestTable.upsert(
    onUpdate = {
        it[Words.count] = Words.count + 1
    }
) {
    it[word] = &quot;Kotlin&quot;
    it[count] = 3
}

// after - with new value from insert used in update expression
TestTable.upsert(
    onUpdate = {
        it[Words.count] = Words.count + insertValue(Words.count)
    }
) {
    it[word] = &quot;Kotlin&quot;
    it[count] = 3
}
</div><ul class="list _bullet" id="dfntvj_130"><li class="list__item" id="dfntvj_131"><p id="dfntvj_132">The function <code class="code" id="dfntvj_133">statementsRequiredForDatabaseMigration</code> has been moved from <code class="code" id="dfntvj_134">SchemaUtils</code> to <code class="code" id="dfntvj_135">MigrationUtils</code> in the <code class="code" id="dfntvj_136">exposed-migration</code> module.</p></li><li class="list__item" id="dfntvj_137"><p id="dfntvj_138">A nested transaction (with <code class="code" id="dfntvj_139">useNestedTransactions = true</code>) that throws any exception will now rollback any commits since the last savepoint. This ensures that the nested transaction is properly configured to act in the exact same way as a top-level transaction or <code class="code" id="dfntvj_140">inTopLevelTransaction()</code>.</p><p id="dfntvj_141">An inner transaction (with <code class="code" id="dfntvj_142">useNestedTransactions = false</code>) that throws any exception will also rollback any commits since the last savepoint. This ensures that any exception propagated from the inner transaction to the outer transaction will not be swallowed if caught by some exception handler wrapping the inner transaction, and any inner commits will not be saved. In version 0.55.0, this change will be reduced so that only inner transactions that throw an <code class="code" id="dfntvj_143">SQLException</code> from the database will trigger such a rollback.</p></li></ul></section><section class="chapter"><h2 id="0-53-0" data-toc="0-53-0">0.53.0</h2><ul class="list _bullet" id="dfntvj_144"><li class="list__item" id="dfntvj_145"><p>DAO Entity Transformation Changes </p><ul class="list _bullet" id="dfntvj_146"><li class="list__item" id="dfntvj_147"><p id="dfntvj_148"><span class="control" id="dfntvj_149">Parameter Renaming</span>: <code class="code" id="dfntvj_150">transform()</code> and <code class="code" id="dfntvj_151">memoizedTransform()</code> now use <code class="code" id="dfntvj_152">wrap</code> and <code class="code" id="dfntvj_153">unwrap</code> instead of <code class="code" id="dfntvj_154">toColumn</code> and <code class="code" id="dfntvj_155">toReal</code>.</p><div class="code-block" data-lang="kotlin">
// Old:
var name by EmployeeTable.name.transform(toColumn = { it.uppercase() }, toReal = { it.lowercase() })
// New:
var name by EmployeeTable.name.transform(wrap = { it.uppercase() }, unwrap = { it.lowercase() })
</div></li><li class="list__item" id="dfntvj_157"><p id="dfntvj_158"><span class="control" id="dfntvj_159">Class Renaming</span>: <code class="code" id="dfntvj_160">ColumnWithTransform</code> is now <code class="code" id="dfntvj_161">EntityFieldWithTransform</code>, consolidating properties into a single <code class="code" id="dfntvj_162">transformer</code>.</p><div class="code-block" data-lang="kotlin">
EntityFieldWithTransform(column, object : ColumnTransformer&lt;String, Int&gt; {
        override fun unwrap(value: Int): String = value.toString()
        override fun wrap(value: String): Int = value.toInt()
    })
</div></li><li class="list__item" id="dfntvj_164"><p id="dfntvj_165">Entity transformation via DAO is deprecated and should be replaced with DSL transformation.</p><div class="code-block" data-lang="kotlin">
val tester = object : Table() {
        val value = integer(&quot;value&quot;)
            .transform(wrap = { ... }, unwrap = { ... })
    }
</div></li></ul></li></ul></section><section class="chapter"><h2 id="0-51-0" data-toc="0-51-0">0.51.0</h2><ul class="list _bullet" id="dfntvj_167"><li class="list__item" id="dfntvj_168"><p>The <code class="code" id="dfntvj_169">exposed-spring-boot-starter</code> module no longer provides the entire <a href="https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-jdbc" id="dfntvj_170" data-external="true" rel="noopener noreferrer">spring-boot-starter-data-jdbc</a> module. It now provides just the <a href="https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-jdbc" id="dfntvj_171" data-external="true" rel="noopener noreferrer">spring-boot-starter-jdbc</a>. If there was a reliance on this transitive dependency, please directly include a dependency on Spring Data JDBC in your build files.</p></li><li class="list__item" id="dfntvj_172"><p><code class="code" id="dfntvj_173">ulong</code> column type is now NUMERIC(20) instead of BIGINT for H2 (excluding H2_PSQL), SQLite, and SQL Server to allow storing the full range of <code class="code" id="dfntvj_174">ULong</code>, including <code class="code" id="dfntvj_175">ULong.MAX_VALUE</code>.</p></li></ul></section><section class="chapter"><h2 id="0-50-0" data-toc="0-50-0">0.50.0</h2><ul class="list _bullet" id="dfntvj_176"><li class="list__item" id="dfntvj_177"><p>The <code class="code" id="dfntvj_178">Transaction</code> class property <code class="code" id="dfntvj_179">repetitionAttempts</code> is being deprecated in favor of <code class="code" id="dfntvj_180">maxAttempts</code>. Additionally, the property <code class="code" id="dfntvj_181">minRepetitionDelay</code> should be replaced with <code class="code" id="dfntvj_182">minRetryDelay</code>, and <code class="code" id="dfntvj_183">maxRepetitionDelay</code> with <code class="code" id="dfntvj_184">maxRetryDelay</code>. These changes also affect the default variants of these properties in <code class="code" id="dfntvj_185">DatabaseConfig</code>.</p></li><li class="list__item" id="dfntvj_186"><p>The property <code class="code" id="dfntvj_187">maxAttempts</code> represents the maximum amount of attempts to perform a transaction block. Setting it, or the now deprecated <code class="code" id="dfntvj_188">repetitionAttempts</code>, to a value less than 1 now throws an <code class="code" id="dfntvj_189">IllegalArgumentException</code>.</p></li><li class="list__item" id="dfntvj_190"><p><code class="code" id="dfntvj_191">IColumnType</code> and <code class="code" id="dfntvj_192">ColumnType</code> now expect a type argument. <code class="code" id="dfntvj_193">IColumnType.valueFromDB()</code> also no longer has a default implementation, so an override for this method must be provided in any custom column type implementation. Check this <a href="https://github.com/JetBrains/Exposed/pull/2027" id="dfntvj_194" data-external="true" rel="noopener noreferrer">pull request</a> for details regarding this change.</p></li></ul></section><section class="chapter"><h2 id="0-49-0" data-toc="0-49-0">0.49.0</h2><ul class="list _bullet" id="dfntvj_195"><li class="list__item" id="dfntvj_196"><p>For SQLite database, Exposed now requires bumping the SQLite JDBC driver version to a minimum of 3.45.0.0.</p></li></ul></section><section class="chapter"><h2 id="0-48-0" data-toc="0-48-0">0.48.0</h2><ul class="list _bullet" id="dfntvj_197"><li class="list__item" id="dfntvj_198"><p>In <code class="code" id="dfntvj_199">nonNullValueToString</code> for <code class="code" id="dfntvj_200">KotlinInstantColumnType</code> and <code class="code" id="dfntvj_201">JavaDateColumnType</code>, the formatted String for MySQL did not match the format received from the metadata when <code class="code" id="dfntvj_202">isFractionDateTimeSupported</code> is true, so a new formatter specific to that is now used.</p></li><li class="list__item" id="dfntvj_203"><p>In <code class="code" id="dfntvj_204">nonNullValueToString</code> for <code class="code" id="dfntvj_205">KotlinLocalDateTimeColumnType</code>, the formatted String for MySQL did not match the format received from the metadata when <code class="code" id="dfntvj_206">isFractionDateTimeSupported</code> is true, so a new formatter specific to MySQL is now used.</p></li><li class="list__item" id="dfntvj_207"><p>In <code class="code" id="dfntvj_208">nonNullValueToString</code> for <code class="code" id="dfntvj_209">DateColumnType</code>, <code class="code" id="dfntvj_210">JavaLocalDateTimeColumnType</code>, <code class="code" id="dfntvj_211">JavaLocalTimeColumnType</code>, <code class="code" id="dfntvj_212">JavaInstantColumnType</code>, <code class="code" id="dfntvj_213">KotlinLocalDateTimeColumnType</code>, <code class="code" id="dfntvj_214">KotlinLocalTimeColumnType</code>, and <code class="code" id="dfntvj_215">KotlinInstantColumnType</code>, the correct formatter for MySQL is used when the version (below 5.6) does not support fractional seconds.</p></li><li class="list__item" id="dfntvj_216"><p>In <code class="code" id="dfntvj_217">nonNullValueToString</code> for <code class="code" id="dfntvj_218">DateColumnType</code> and <code class="code" id="dfntvj_219">DateTimeWithTimeZoneColumnType</code>, the formatters used are changed to reflect the fact that Joda-Time stores date/time values only down to the millisecond (up to SSS and not SSSSSS).</p></li><li class="list__item" id="dfntvj_220"><p>Functions <code class="code" id="dfntvj_221">anyFrom(array)</code> and <code class="code" id="dfntvj_222">allFrom(array)</code> now use <code class="code" id="dfntvj_223">ArrayColumnType</code> to process the provided array argument when query building. <code class="code" id="dfntvj_224">ArrayColumnType</code> requires a base column type to process contents correctly, and Exposed attempts to resolve the best match internally based on the array content type. A specific column type argument should be provided to the function parameter <code class="code" id="dfntvj_225">delegateType</code> if the content requires either an unsupported or custom column type, or a column type not defined in the <code class="code" id="dfntvj_226">exposed-core</code> module.</p></li><li class="list__item" id="dfntvj_227"><p><code class="code" id="dfntvj_228">exposed-crypt</code> module now uses Spring Security Crypto 6.+, which requires Java 17 as a minimum version.</p></li></ul></section><section class="chapter"><h2 id="0-47-0" data-toc="0-47-0">0.47.0</h2><ul class="list _bullet" id="dfntvj_229"><li class="list__item" id="dfntvj_230"><p>The function <code class="code" id="dfntvj_231">SchemaUtils.checkExcessiveIndices</code> is used to check both excessive indices and excessive foreign key constraints. It now has a different behavior and deals with excessive indices only. Also, its return type is now <code class="code" id="dfntvj_232">List&lt;Index&gt;</code> instead of <code class="code" id="dfntvj_233">Unit</code>. A new function, <code class="code" id="dfntvj_234">SchemaUtils.checkExcessiveForeignKeyConstraints</code>, deals with excessive foreign key constraints and has a return type <code class="code" id="dfntvj_235">List&lt;ForeignKeyConstraint&gt;</code>.</p></li></ul></section><section class="chapter"><h2 id="0-46-0" data-toc="0-46-0">0.46.0</h2><ul class="list _bullet" id="dfntvj_236"><li class="list__item" id="dfntvj_237"><p id="dfntvj_238">When an Exposed table object is created with a keyword identifier (a table or column name) it now retains the exact case used before being automatically quoted in generated SQL. This primarily affects H2 and Oracle, both of which support folding identifiers to uppercase, and PostgresSQL, which folds identifiers to a lower case.</p><p id="dfntvj_239">If <code class="code" id="dfntvj_240">preserveKeywordCasing = true</code> had been previously set in <code class="code" id="dfntvj_241">DatabaseConfig</code> to remove logged warnings about any keyword identifiers, this can now be removed as the property is <code class="code" id="dfntvj_242">true</code> by default.</p><p id="dfntvj_243">To temporarily opt out of this behavior and to not keep the defined casing of keyword identifiers, please set <code class="code" id="dfntvj_244">preserveKeywordCasing = false</code> in <code class="code" id="dfntvj_245">DatabaseConfig</code>:</p></li></ul><div class="code-block" data-lang="kotlin">
object TestTable : Table(&quot;table&quot;) {
    val col = integer(&quot;select&quot;)
}

// default behavior (preserveKeywordCasing is by default set to true)
// H2 generates SQL -&gt; CREATE TABLE IF NOT EXISTS &quot;table&quot; (&quot;select&quot; INT NOT NULL)

// with opt-out
Database.connect(
    url = &quot;jdbc:h2:mem:test&quot;,
    driver = &quot;org.h2.Driver&quot;,
    databaseConfig = DatabaseConfig {
        @OptIn(ExperimentalKeywordApi::class)
        preserveKeywordCasing = false
    }
)
// H2 generates SQL -&gt; CREATE TABLE IF NOT EXISTS &quot;TABLE&quot; (&quot;SELECT&quot; INT NOT NULL)
</div><aside class="prompt" data-type="note" data-title="" id="dfntvj_247"><p>The `preserveKeywordCasing` is an experimental flag and requires `@OptIn`. It may become deprecated in future releases.</p></aside></section><section class="chapter"><h2 id="0-44-0" data-toc="0-44-0">0.44.0</h2><ul class="list _bullet" id="dfntvj_248"><li class="list__item" id="dfntvj_249"><p id="dfntvj_250"><code class="code" id="dfntvj_251">SpringTransactionManager</code> no longer extends <code class="code" id="dfntvj_252">DataSourceTransactionManager</code>; instead, it directly extends <code class="code" id="dfntvj_253">AbstractPlatformTransactionManager</code> while retaining the previous basic functionality. The class also no longer implements the Exposed interface <code class="code" id="dfntvj_254">TransactionManager</code>, as transaction operations are instead delegated to Spring. These changes ensure that Exposed's underlying transaction management no longer interferes with the expected behavior of Spring's transaction management, for example, when using nested transactions or with <code class="code" id="dfntvj_255">@Transactional</code> elements like <code class="code" id="dfntvj_256">propagation</code> or <code class="code" id="dfntvj_257">isolation</code>.</p><p id="dfntvj_258">If integration still requires a <code class="code" id="dfntvj_259">DataSourceTransactionManager</code>, please add two bean declarations to the configuration: one for <code class="code" id="dfntvj_260">SpringTransactionManager</code> and one for <code class="code" id="dfntvj_261">DataSourceTransactionManager</code>. Then define a composite transaction manager that combines these two managers.</p><p id="dfntvj_262">If <code class="code" id="dfntvj_263">TransactionManager</code> functions were being invoked by a <code class="code" id="dfntvj_264">SpringTransactionManager</code> instance, please replace these calls with the appropriate Spring annotation or, if necessary, by using the companion object of <code class="code" id="dfntvj_265">TransactionManager</code> directly (for example, <code class="code" id="dfntvj_266">TransactionManager.currentOrNull()</code>).</p></li><li class="list__item" id="dfntvj_267"><p id="dfntvj_268"><code class="code" id="dfntvj_269">spring-transaction</code> and <code class="code" id="dfntvj_270">exposed-spring-boot-starter</code> modules now use Spring Framework 6.0 and Spring Boot 3.0, which require Java 17 as a minimum version.</p></li><li class="list__item" id="dfntvj_271"><p id="dfntvj_272">A table that is created with a keyword identifier (a table or column name) now logs a warning that the identifier's case may be lost when it is automatically quoted in generated SQL. This primarily affects H2 and Oracle, both of which support folding identifiers to uppercase, and PostgreSQL, which folds identifiers to a lower case.</p><p id="dfntvj_273">To remove these warnings and to ensure that the keyword identifier sent to the database matches the exact case used in the Exposed table object, please set <code class="code" id="dfntvj_274">preserveKeywordCasing = true</code> in <code class="code" id="dfntvj_275">DatabaseConfig</code>:</p></li></ul><div class="code-block" data-lang="kotlin">
object TestTable : Table(&quot;table&quot;) {
    val col = integer(&quot;select&quot;)
}

// without opt-in (default set to false)
// H2 generates SQL -&gt; CREATE TABLE IF NOT EXISTS &quot;TABLE&quot; (&quot;SELECT&quot; INT NOT NULL)

// with opt-in
Database.connect(
    url = &quot;jdbc:h2:mem:test&quot;,
    driver = &quot;org.h2.Driver&quot;,
    databaseConfig = DatabaseConfig {
        @OptIn(ExperimentalKeywordApi::class)
        preserveKeywordCasing = true
    }
)
// H2 generates SQL -&gt; CREATE TABLE IF NOT EXISTS &quot;table&quot; (&quot;select&quot; INT NOT NULL)
</div><aside class="prompt" data-type="note" data-title="" id="dfntvj_277"><p>`preserveKeywordCasing` is an experimental flag and requires `@OptIn`. It may become deprecated in future releases, and its behavior when set to `true` may become the default.</p></aside></section><section class="chapter"><h2 id="0-43-0" data-toc="0-43-0">0.43.0</h2><ul class="list _bullet" id="dfntvj_278"><li class="list__item" id="dfntvj_279"><p>In all databases except MySQL, MariaDB, and SQL Server, the <code class="code" id="dfntvj_280">ubyte()</code> column now maps to data type <code class="code" id="dfntvj_281">SMALLINT</code> instead of <code class="code" id="dfntvj_282">TINYINT</code>, which allows the full range of <code class="code" id="dfntvj_283">UByte</code> values to be inserted without any overflow. Registering the column on a table also creates a check constraint that restricts inserted data to the range between 0 and <code class="code" id="dfntvj_284">UByte.MAX_VALUE</code>. If a column that only uses 1 byte of storage is needed, but without allowing any non-negative values to be inserted, please use a signed <code class="code" id="dfntvj_285">byte()</code> column instead with a manually created check constraint:</p></li></ul><div class="code-block" data-lang="kotlin">
byte(&quot;number&quot;).check { it.between(0, Byte.MAX_VALUE) }
// OR
byte(&quot;number&quot;).check { (it greaterEq 0) and (it lessEq Byte.MAX_VALUE) }
</div><ul class="list _bullet" id="dfntvj_287"><li class="list__item" id="dfntvj_288"><p>In all databases except MySQL and MariaDB, the <code class="code" id="dfntvj_289">uint()</code> column now maps to data type <code class="code" id="dfntvj_290">BIGINT</code> instead of <code class="code" id="dfntvj_291">INT</code>, which allows the full range of <code class="code" id="dfntvj_292">UInt</code> values to be inserted without any overflow. Registering the column on a table also creates a check constraint that restricts inserted data to the range between 0 and <code class="code" id="dfntvj_293">UInt.MAX_VALUE</code>. If a column that only uses 4 bytes of storage is needed, but without allowing any non-negative values to be inserted, please use a signed <code class="code" id="dfntvj_294">integer()</code> column instead with a manually created check constraint:</p></li></ul><div class="code-block" data-lang="kotlin">
integer(&quot;number&quot;).check { it.between(0, Int.MAX_VALUE) }
// OR
integer(&quot;number&quot;).check { (it greaterEq 0) and (it lessEq Int.MAX_VALUE) }
</div></section><section class="chapter"><h2 id="0-42-0" data-toc="0-42-0">0.42.0</h2><ul class="list _bullet" id="dfntvj_296"><li class="list__item" id="dfntvj_297"><p><span class="control" id="dfntvj_298">SQLite</span> The table column created using <code class="code" id="dfntvj_299">date()</code> now uses TEXT datatype instead of DATE (which the database mapped internally to NUMERIC type). This applies to the specific <code class="code" id="dfntvj_300">DateColumnType</code> in all 3 date/time modules and means <code class="code" id="dfntvj_301">LocalDate</code> comparisons can now be done directly without conversions.</p></li><li class="list__item" id="dfntvj_302"><p><span class="control" id="dfntvj_303">H2, PostgreSQL</span> Using <code class="code" id="dfntvj_304">replace()</code> now throws an exception as the REPLACE command is not supported by these databases. If <code class="code" id="dfntvj_305">replace()</code> was being used to perform an insert or update operation, all usages should instead be switched to <code class="code" id="dfntvj_306">upsert()</code>. <a href="dsl-crud-operations.html#insert-or-update" id="dfntvj_307" data-tooltip="Insert or update (Upsert) is a database operation that either inserts a new row or updates an existing row if a duplicate constraint already exists. The supported functionality of upsert() is dependent on the specific database being used. For example, MySQL's INSERT ... ON DUPLICATE…">See documentation for UPSERT details</a></p></li><li class="list__item" id="dfntvj_308"><p>Operator classes <code class="code" id="dfntvj_309">exists</code> and <code class="code" id="dfntvj_310">notExists</code> have been renamed to <code class="code" id="dfntvj_311">Exists</code> and <code class="code" id="dfntvj_312">NotExists</code>. The functions <code class="code" id="dfntvj_313">exists()</code> and <code class="code" id="dfntvj_314">notExists()</code> have been introduced to return an instance of their respectively-named classes and to avoid unresolved reference issues. Any usages of these classes should be renamed to their capitalized forms.</p></li><li class="list__item" id="dfntvj_315"><p><code class="code" id="dfntvj_316">customEnumeration()</code> now registers a <code class="code" id="dfntvj_317">CustomEnumerationColumnType</code> to allow referencing by another column. The signature of <code class="code" id="dfntvj_318">customEnumeration()</code> has not changed and table columns initialized using it are still of type <code class="code" id="dfntvj_319">Column&lt;DataClass&gt;</code>.</p></li><li class="list__item" id="dfntvj_320"><p><code class="code" id="dfntvj_321">Transaction.suspendedTransaction()</code> has been renamed to <code class="code" id="dfntvj_322">Transaction.withSuspendTransaction()</code>. Please run <code class="code" id="dfntvj_323">Edit -&gt; Find -&gt; Replace in files...</code> twice with <code class="code" id="dfntvj_324">suspendedTransaction(</code> and <code class="code" id="dfntvj_325">suspendedTransaction</code> as the search options, to ensure that both variants are replaced without affecting <code class="code" id="dfntvj_326">suspendedTransactionAsync()</code> (if used in code).</p></li><li class="list__item" id="dfntvj_327"><p>The <code class="code" id="dfntvj_328">repetitionAttempts</code> parameter in <code class="code" id="dfntvj_329">transaction()</code> has been removed and replaced with a mutable property in the <code class="code" id="dfntvj_330">Transaction</code> class. Please remove any arguments for this parameter and assign values to the property directly:</p></li></ul><div class="code-block" data-lang="kotlin">
// before
transaction(Connection.TRANSACTION_READ_COMMITTED, repetitionAttempts = 10) {
    // statements
}

// after
transaction(Connection.TRANSACTION_READ_COMMITTED) {
    repetitionAttempts = 10
    // statements
}
</div><ul class="list _bullet" id="dfntvj_332"><li class="list__item" id="dfntvj_333"><p>In all databases except MySQL and MariaDB, the <code class="code" id="dfntvj_334">ushort()</code> column now maps to data type <code class="code" id="dfntvj_335">INT</code> instead of <code class="code" id="dfntvj_336">SMALLINT</code>, which allows the full range of <code class="code" id="dfntvj_337">UShort</code> values to be inserted without any overflow. Registering the column on a table also creates a check constraint that restricts inserted data to the range between 0 and <code class="code" id="dfntvj_338">UShort.MAX_VALUE</code>. If a column that only uses 2 bytes of storage is needed, but without allowing any non-negative values to be inserted, please use a signed <code class="code" id="dfntvj_339">short()</code> column instead with a manually created check constraint:</p></li></ul><div class="code-block" data-lang="kotlin">
short(&quot;number&quot;).check { it.between(0, Short.MAX_VALUE) }
// OR
short(&quot;number&quot;).check { (it greaterEq 0) and (it lessEq Short.MAX_VALUE) }
</div></section><div class="last-modified">Last modified: 30 October 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="dao-field-transformations.html" class="navigation-links__prev">Field transformations</a><a href="migration-guide.html" class="navigation-links__next">Migrating from 0.45.0 to 0.46.0</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b267/app.js"></script></body></html>