package org.jetbrains.exposed.sql.statements.jdbc

import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.asFlow
import kotlinx.coroutines.flow.flowOf
import org.jetbrains.exposed.sql.statements.api.ResultApi
import java.sql.ResultSet

/** Class for wrapping a [java.sql.ResultSet] generated by executing a statement that queries a JDBC database. */
class JdbcResult(
    /** The actual [ResultSet] returned by the database after statement execution. */
    override val result: ResultSet
) : ResultApi {
    override fun toString(): String = "JdbcResult(resultSet = $result)"

    override fun getObject(index: Int): Any? = result.getObject(index)

    override fun <T> getObject(index: Int, type: Class<T>): T? = result.getObject(index, type)

    override fun metadataColumnCount(): Int = result.metaData.columnCount

    override fun metadataColumnName(index: Int): String = result.metaData.getColumnName(index)

    override fun metadataColumnIndex(label: String): Int = result.findColumn(label)

    override fun next(): Boolean = result.next()

    override fun <T> collectAll(transform: (ResultApi) -> T): Flow<T> {
        val transformed = sequence {
            while (next()) {
                yield(transform(this@JdbcResult))
            }
        }
        return transformed.asFlow()
    }

    override fun <T> collectSingle(transform: (ResultApi) -> T): Flow<T> {
        result.next()
        return flowOf(transform(this))
    }

    override fun close() {
        result.close()
    }

    override fun releaseResult() {
        val statement = result.statement
        close()
        statement?.close()
    }
}
