package org.jetbrains.exposed.sql.statements.jdbc

import org.jetbrains.exposed.sql.BinaryColumnType
import org.jetbrains.exposed.sql.BlobColumnType
import org.jetbrains.exposed.sql.IColumnType
import org.jetbrains.exposed.sql.statements.StatementResult
import org.jetbrains.exposed.sql.statements.api.PreparedStatementApi
import java.io.ByteArrayInputStream
import java.io.FileInputStream
import org.jetbrains.exposed.sql.vendors.SQLiteDialect
import org.jetbrains.exposed.sql.vendors.currentDialect
import java.io.InputStream
import java.sql.PreparedStatement
import java.sql.ResultSet
import java.sql.Statement
import java.sql.SQLFeatureNotSupportedException
import java.sql.Types

/**
 * Class representing a precompiled SQL [statement].
 *
 * The result set generated by executing this statement contains auto-generated keys based on the value of
 * [wasGeneratedKeysRequested] and if the JDBC driver implementation [supportsGetGeneratedKeys].
 */
class JdbcPreparedStatementImpl(
    val statement: PreparedStatement,
    val wasGeneratedKeysRequested: Boolean,
    private val supportsGetGeneratedKeys: Boolean
) : PreparedStatementApi {
    override val resultSet: ResultSet?
        get() = when {
            !wasGeneratedKeysRequested -> statement.resultSet
            supportsGetGeneratedKeys -> statement.generatedKeys
            currentDialect is SQLiteDialect -> {
                statement.connection.prepareStatement("select last_insert_rowid();").executeQuery()
            }
            else -> statement.resultSet
        }

    override var fetchSize: Int?
        get() = statement.fetchSize
        set(value) {
            value?.let { statement.fetchSize = value }
        }

    override var timeout: Int?
        get() = statement.queryTimeout
        set(value) {
            value?.let { statement.queryTimeout = it }
        }

    override fun addBatch() {
        statement.addBatch()
    }

    override fun executeQuery(): ResultSet = statement.executeQuery()

    override fun executeUpdate(): Int = statement.executeUpdate()

    override fun executeMultiple(): List<StatementResult> {
        // execute() returns true only if first result is a ResultSet
        return if (statement.execute()) {
            listOf(StatementResult.Object(statement.resultSet))
        } else {
            // getMoreResults() returns true only if next result is a ResultSet
            while (!statement.getMoreResults(Statement.CLOSE_CURRENT_RESULT)) {
                if (statement.updateCount == -1) return emptyList()
            }
            listOf(StatementResult.Object(statement.resultSet))
        }
    }

    override fun set(index: Int, value: Any) {
        statement.setObject(index, value)
    }

    override fun setNull(index: Int, columnType: IColumnType) {
        if (columnType is BinaryColumnType || columnType is BlobColumnType) {
            statement.setNull(index, Types.LONGVARBINARY)
        } else {
            statement.setObject(index, null)
        }
    }

    override fun setInputStream(index: Int, inputStream: InputStream) {
        try {
            when {
                // streams with known length where available matches the actual length
                inputStream is ByteArrayInputStream ->
                    statement.setBinaryStream(index, inputStream, inputStream.available())

                // FileInputStream.available() returns returns Int.MAX_VALUE
                // if the underlying file is larger than 2GB
                inputStream is FileInputStream && inputStream.available() < Int.MAX_VALUE ->
                    statement.setBinaryStream(index, inputStream, inputStream.available())

                // default handling for unknown length
                else -> statement.setBinaryStream(index, inputStream)

            }
        } catch (e: SQLFeatureNotSupportedException) {
            // fallback to bytes
            statement.setBytes(index, inputStream.readBytes())
        }
    }

    override fun setArray(index: Int, type: String, array: Array<*>) {
        statement.setArray(index, statement.connection.createArrayOf(type, array))
    }

    override fun closeIfPossible() {
        if (!statement.isClosed) statement.close()
    }

    override fun executeBatch(): List<Int> {
        return statement.executeBatch().map {
            when (it) {
                Statement.SUCCESS_NO_INFO -> 1
                Statement.EXECUTE_FAILED -> 0
                else -> it
            }
        }
    }

    override fun cancel() {
        if (!statement.isClosed) statement.cancel()
    }
}
