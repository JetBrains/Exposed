package org.jetbrains.exposed.v1.spring.boot.r2dbc.autoconfigure

import kotlinx.coroutines.test.TestScope
import kotlinx.coroutines.test.runTest
import org.jetbrains.exposed.v1.core.InternalApi
import org.jetbrains.exposed.v1.core.transactions.ThreadLocalTransactionsStack
import org.jetbrains.exposed.v1.r2dbc.exists
import org.jetbrains.exposed.v1.r2dbc.selectAll
import org.jetbrains.exposed.v1.spring.boot.r2dbc.Application
import org.jetbrains.exposed.v1.spring.boot.r2dbc.tables.TestTable
import org.jetbrains.exposed.v1.spring.boot.r2dbc.tables.ignore.IgnoreTable
import org.jetbrains.exposed.v1.spring.reactive.transaction.SpringReactiveTransactionManager
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertFalse
import org.junit.jupiter.api.Assertions.assertNotNull
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.test.context.event.annotation.BeforeTestClass
import org.springframework.transaction.ReactiveTransaction
import org.springframework.transaction.reactive.TransactionalOperator
import org.springframework.transaction.reactive.executeAndAwait

@SpringBootTest(
    classes = [Application::class],
    properties = [
        "spring.r2dbc.url=r2dbc:h2:mem:///test;DB_CLOSE_DELAY=-1;",
        "spring.exposed.generate-ddl=true",
        "spring.exposed.show-sql=true"
    ]
)
open class ExposedAutoConfigurationTestAutoGenerateDDL {
    @Autowired(required = false)
    private var springReactiveTransactionManager: SpringReactiveTransactionManager? = null

    @OptIn(InternalApi::class)
    @BeforeTestClass
    fun beforeTest() {
        // TODO - this should not be done, but transactions are not being popped on original thread after coroutine switches thread
        ThreadLocalTransactionsStack.threadTransactions()
            ?.joinToString(separator = "\n", prefix = "\n!!! ORPHAN transactions:\n") { "--> $it" }
            ?.ifEmpty { "NO transactions to clear up :)" }
            ?.also { println(it) }
        ThreadLocalTransactionsStack.threadTransactions()?.clear()
    }

    @Test
    fun `should initialize the database connection`() {
        assertNotNull(springReactiveTransactionManager)
    }

    @Test
//    @Transactional // see [runTestWithMockTransactional]
    open fun `should create schema for all object tables`() {
        springReactiveTransactionManager.runTestWithMockTransactional {
            assertEquals(0L, TestTable.selectAll().count())
            assertEquals(0L, IgnoreTable.selectAll().count())
        }
    }
}

@SpringBootTest(
    classes = [Application::class],
    properties = [
        "spring.r2dbc.url=r2dbc:h2:mem:///test;DB_CLOSE_DELAY=-1;",
        "spring.exposed.generate-ddl=true",
        "spring.exposed.show-sql=true",
        "spring.exposed.excluded-packages=org.jetbrains.exposed.v1.spring.boot.r2dbc.tables.ignore"
    ]
)
open class ExposedAutoConfigurationTestExcludeDDL {
    @Autowired(required = false)
    private var springReactiveTransactionManager: SpringReactiveTransactionManager? = null

    @OptIn(InternalApi::class)
    @BeforeTestClass
    fun beforeTest() {
        // TODO - this should not be done, but transactions are not being popped on original thread after coroutine switches thread
        ThreadLocalTransactionsStack.threadTransactions()
            ?.joinToString(separator = "\n", prefix = "\n!!! ORPHAN transactions:\n") { "--> $it" }
            ?.ifEmpty { "NO transactions to clear up :)" }
            ?.also { println(it) }
        ThreadLocalTransactionsStack.threadTransactions()?.clear()
    }

    @Test
    fun `should initialize the database connection`() {
        assertNotNull(springReactiveTransactionManager)
    }

    @Test
//    @Transactional // see [runTestWithMockTransactional]
    open fun `should create schema for TestTable and not for IgnoreTable`() {
        springReactiveTransactionManager.runTestWithMockTransactional {
            assertEquals(0L, TestTable.selectAll().count())
            assertFalse(IgnoreTable.exists())
        }
    }
}

/**
 * Invokes [runTest] with the [testBody] executed by a [TransactionalOperator] that is set up to follow the same
 * rollback rules as `@Transactional`.
 *
 * Currently, `@Transactional` in Spring's `TestContext` is only configured to find a `PlatformTransactionManager`,
 * so it is completely unusable for Spring-R2dbc unit tests.
 *
 * [Open Issue](https://github.com/spring-projects/spring-framework/issues/24226)
 */
private fun SpringReactiveTransactionManager?.runTestWithMockTransactional(
    testBody: suspend TestScope.(ReactiveTransaction) -> Unit
) {
    runTest {
        val trxOp = TransactionalOperator.create(this@runTestWithMockTransactional!!)
        trxOp.executeAndAwait {
            testBody(it)
            it.setRollbackOnly()
        }
    }
}
