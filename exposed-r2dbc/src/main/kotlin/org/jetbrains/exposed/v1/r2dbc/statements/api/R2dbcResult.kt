package org.jetbrains.exposed.v1.r2dbc.statements.api

import io.r2dbc.postgresql.codec.Json
import io.r2dbc.spi.Result
import io.r2dbc.spi.Row
import io.r2dbc.spi.RowMetadata
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.collect
import kotlinx.coroutines.flow.count
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.reactive.asPublisher
import kotlinx.coroutines.reactive.collect
import org.jetbrains.exposed.v1.core.statements.api.ResultApi
import org.jetbrains.exposed.v1.core.statements.api.RowApi
import org.jetbrains.exposed.v1.core.vendors.MariaDBDialect
import org.jetbrains.exposed.v1.core.vendors.MysqlDialect
import org.jetbrains.exposed.v1.core.vendors.currentDialect
import org.reactivestreams.Publisher
import java.sql.Date
import java.sql.Time
import java.sql.Timestamp
import java.time.Instant
import java.time.LocalDate
import java.time.LocalDateTime
import java.time.LocalTime
import java.util.*
import kotlin.jvm.optionals.getOrNull

/**
 * Class for wrapping an [Row] generated by executing a statement that queries an R2DBC database.
 *
 * @property resultPublisher The actual [Result] returned by the database after statement execution.
 */
class R2dbcResult internal constructor(
    private val resultPublisher: Publisher<out Result>
) : ResultApi {
    private var consumed = false

    override fun <T> mapRows(block: (RowApi) -> T?): Flow<T?> {
        if (consumed) error("Result is already consumed")
        consumed = true

        return flow {
            resultPublisher.collect { result ->
                result.map { row, rm ->
                    Optional.ofNullable(block(R2DBCRow(row)))
                }.collect { emit(it.getOrNull()) }
            }
        }
    }

    fun <T : Any> mapSegments(block: (Result.Segment) -> Flow<T>): Flow<T> = flow {
        resultPublisher.collect { result ->
            result.flatMap<T> { segment ->
                val rf = block(segment)
                rf.asPublisher()
            }.collect { emit(it) }
        }
    }

    // Todo relies on rowsUpdated throwing ISE if already consumed; should we fail earlier as in mapRows()?
    fun rowsUpdated(): Flow<Int> = flow {
        resultPublisher.collect { result ->
            result.rowsUpdated.collect { count ->
                emit(count.toInt())
            }
        }
    }

    // terminal operation to trigger final collection of flow, but ignore emitting values
    suspend fun collect() {
        mapRows { }.collect()
    }

    override fun toString(): String = "R2dbcResult(resultPublisher = $resultPublisher)"

    override fun close() = Unit
}

@JvmInline
value class R2DBCRow(val row: Row) : RowApi {
    override fun getObject(index: Int): Any? {
        val result = row.get(index - 1)
        return when (result) {
            is Json -> result.asString()
            else -> result
        }
    }

    override fun getObject(name: String): Any? = row.get(name)

    override fun <T> getObject(index: Int, type: Class<T>): T? = when (type) {
        Time::class.java -> {
            val result: LocalTime = row.get(index - 1, LocalTime::class.java) ?: return null
            @Suppress("UNCHECKED_CAST")
            Time.valueOf(result) as T
        }
        Date::class.java -> {
            val result: LocalDate? = row.get(index - 1, LocalDate::class.java) ?: return null
            @Suppress("UNCHECKED_CAST")
            Date.valueOf(result) as T
        }
        Timestamp::class.java -> {
            // It is tricky, probably the reason for MySql special case is not here but in `KotlinInstantColumnType`
            // The problem is that the line `rs.getObject(index, java.sql.Timestamp::class.java)` in method `valueFromDB()` inside
            // the column type changes the time according to the time zone, and reverts it back in `valueFromDB`
            // But for R2DBC it does not happen. This line changes that behaviour to match it to JDBC behaviour.
            if (currentDialect is MysqlDialect && currentDialect !is MariaDBDialect) {
                val result: Instant = row.get(index - 1, Instant::class.java) ?: return null
                @Suppress("UNCHECKED_CAST")
                Timestamp.from(result) as T
            } else {
                try {
                    val result: LocalDateTime = row.get(index - 1, LocalDateTime::class.java) ?: return null
                    @Suppress("UNCHECKED_CAST")
                    Timestamp.valueOf(result) as T
                } catch (_: Exception) {
                    val result: String = row.get(index - 1, String::class.java) ?: return null
                    @Suppress("UNCHECKED_CAST")
                    Timestamp.valueOf(result) as T
                }
            }
        }
        else -> row.get(index - 1, type) as T
    }

    override fun <T> getObject(name: String, type: Class<T>): T? = row.get(name, type)
}

suspend fun ResultApi.rowsCount() = mapRows { }.count()

val RowApi.origin: Row get() = (this as R2DBCRow).row

val RowApi.metadata: RowMetadata get() = (this as R2DBCRow).row.metadata
