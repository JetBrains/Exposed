package org.jetbrains.exposed.v1.r2dbc.statements.api

import io.r2dbc.postgresql.codec.Json
import io.r2dbc.spi.Result
import io.r2dbc.spi.Row
import io.r2dbc.spi.RowMetadata
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.collect
import kotlinx.coroutines.flow.count
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.reactive.asPublisher
import kotlinx.coroutines.reactive.collect
import org.jetbrains.exposed.v1.core.ColumnType
import org.jetbrains.exposed.v1.core.statements.api.ResultApi
import org.jetbrains.exposed.v1.core.statements.api.RowApi
import org.jetbrains.exposed.v1.core.vendors.PostgreSQLDialect
import org.jetbrains.exposed.v1.core.vendors.currentDialect
import org.jetbrains.exposed.v1.r2dbc.mappers.TypeMapperRegistry
import org.reactivestreams.Publisher
import java.util.*
import kotlin.jvm.optionals.getOrNull

/**
 * Class for wrapping an [Row] generated by executing a statement that queries an R2DBC database.
 *
 * @property resultPublisher The actual [Result] returned by the database after statement execution.
 */
class R2dbcResult internal constructor(
    private val resultPublisher: Publisher<out Result>,
    internal val typeMapperRegistry: TypeMapperRegistry
) : ResultApi {
    private var consumed = false

    override fun <T> mapRows(block: (RowApi) -> T?): Flow<T?> {
        if (consumed) error("Result is already consumed")
        consumed = true

        return flow {
            resultPublisher.collect { result ->
                result.map { row, rm ->
                    Optional.ofNullable(block(R2DBCRow(row, typeMapperRegistry)))
                }.collect { emit(it.getOrNull()) }
            }
        }
    }

    fun <T : Any> mapSegments(block: (Result.Segment) -> Flow<T>): Flow<T> = flow {
        resultPublisher.collect { result ->
            result.flatMap<T> { segment ->
                val rf = block(segment)
                rf.asPublisher()
            }.collect { emit(it) }
        }
    }

    // Todo relies on rowsUpdated throwing ISE if already consumed; should we fail earlier as in mapRows()?
    fun rowsUpdated(): Flow<Int> = flow {
        resultPublisher.collect { result ->
            result.rowsUpdated.collect { count ->
                emit(count.toInt())
            }
        }
    }

    // terminal operation to trigger final collection of flow, but ignore emitting values
    suspend fun collect() {
        mapRows { }.collect()
    }

    override fun toString(): String = "R2dbcResult(resultPublisher = $resultPublisher)"

    override fun close() = Unit
}

class R2DBCRow(val row: Row, private val typeMapperRegistry: TypeMapperRegistry) : RowApi {
    override fun getObject(index: Int): Any? {
        val result = row.get(index - 1)
        // the only way to avoid this would be to introduce getValue() functionality to TypeMapper
        return when {
            currentDialect is PostgreSQLDialect && result is Json -> result.asString()
            else -> result
        }
    }

    override fun getObject(name: String): Any? = row.get(name)

    override fun <T> getObject(index: Int, type: Class<T>): T? {
        return row.get(index - 1, type) as T
    }

    override fun <T> getObject(name: String, type: Class<T>): T? = row.get(name, type)

    override fun <T> getObject(index: Int, type: Class<T>, columnType: ColumnType<*>): T? {
        return typeMapperRegistry.getValue(row, type, index, currentDialect, columnType)
    }
}

suspend fun ResultApi.rowsCount() = mapRows { }.count()

val RowApi.origin: Row get() = (this as R2DBCRow).row

val RowApi.metadata: RowMetadata get() = (this as R2DBCRow).row.metadata
