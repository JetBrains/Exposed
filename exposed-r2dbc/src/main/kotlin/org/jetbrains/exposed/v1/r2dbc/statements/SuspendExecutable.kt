package org.jetbrains.exposed.v1.r2dbc.statements

import io.r2dbc.spi.R2dbcException
import org.jetbrains.exposed.v1.core.InternalApi
import org.jetbrains.exposed.v1.core.statements.Statement
import org.jetbrains.exposed.v1.core.statements.StatementContext
import org.jetbrains.exposed.v1.r2dbc.ExposedR2dbcException
import org.jetbrains.exposed.v1.r2dbc.R2dbcTransaction
import org.jetbrains.exposed.v1.r2dbc.statements.api.R2dbcPreparedStatementApi

internal object DefaultValueMarker {
    override fun toString(): String = "DEFAULT"
}

/**
 * Executable provides a customizable execution mechanism for SQL statements within a transaction.
 *
 * This interface allows implementing classes to define specific execution logic specific to an R2DBC driver
 * and customize how the return value is handled.
 * It is primarily used when fine-grained control over statement execution is required.
 *
 * For the blocking JDBC alternative of this interface, see `BlockingExecutable` provided with a dependency on `exposed-jdbc`.
 *
 * ## Usage Example:
 * ```kotlin
 * open class BatchUpsertSuspendExecutable(
 *     override val statement: BatchUpsertStatement
 * ) : BatchInsertSuspendExecutable<BatchUpsertStatement>(statement) {
 *     override suspend fun prepared(transaction: R2dbcTransaction, sql: String): R2dbcPreparedStatementApi {
 *         // We must return values from upsert because returned id could be different depending on insert or upsert happened
 *         if (!currentDialect.supportsOnlyIdentifiersInGeneratedKeys) {
 *             return transaction.connection.prepareStatement(sql, statement.shouldReturnGeneratedValues)
 *         }
 *
 *         return super.prepared(transaction, sql)
 *     }
 * }
 * ```
 *
 * The implemented Executable can be later used in the utility functions like `Table.batchUpsert()`.
 *
 * @param T The return type of the SQL execution result.
 * @param S The type of SQL statement that is executed.
 */
interface SuspendExecutable<out T, S : Statement<T>> {
    /** The actual Exposed [Statement] on which the specific execution logic should be used. */
    val statement: S

    /**
     * Determines the exact way that an SQL statement is executed in a [transaction] and applies any necessary
     * logic before returning the result generated by the executed statement.
     */
    suspend fun R2dbcPreparedStatementApi.executeInternal(transaction: R2dbcTransaction): T?

    /**
     * Uses a [transaction] connection and an [sql] string representation to return a precompiled SQL statement,
     * stored as an implementation of [R2dbcPreparedStatementApi].
     */
    suspend fun prepared(
        transaction: R2dbcTransaction,
        sql: String
    ): R2dbcPreparedStatementApi = transaction.connection.prepareStatement(sql, false)

    /** Whether the SQL statement is meant to be performed as part of a batch execution. */
    val isAlwaysBatch: Boolean
        get() = false

    /**
     * Executes the SQL statement directly in the provided [transaction] and returns the generated result,
     * or `null` if either no result was retrieved or if the transaction blocked statement execution.
     */
    suspend fun execute(transaction: R2dbcTransaction): T? {
        return if (transaction.blockStatementExecution) {
            transaction.explainStatement = statement
            null
        } else {
            transaction.exec(this)
        }
    }
}

@OptIn(InternalApi::class)
internal suspend fun <T, S : Statement<T>> SuspendExecutable<T, S>.executeIn(
    transaction: R2dbcTransaction
): Pair<T?, List<StatementContext>> {
    val arguments = statement.arguments()
    val contexts = if (arguments.any()) {
        arguments.map { args ->
            val context = StatementContext(statement, args)
            R2dbcTransaction.globalInterceptors.forEach { it.beforeExecution(transaction, context) }
            transaction.interceptors.forEach { it.beforeExecution(transaction, context) }
            context
        }
    } else {
        val context = StatementContext(statement, emptyList())
        R2dbcTransaction.globalInterceptors.forEach { it.beforeExecution(transaction, context) }
        transaction.interceptors.forEach { it.beforeExecution(transaction, context) }
        listOf(context)
    }

    val statement = try {
        prepared(transaction, statement.prepareSQL(transaction)).apply {
            setTimeout(transaction.queryTimeout)
        }
    } catch (cause: R2dbcException) {
        throw ExposedR2dbcException(cause, contexts, transaction)
    }
    contexts.forEachIndexed { index, context ->
        statement.fillParameters(context.args)
        // REVIEW

        // We don't need to add batch for the last item in the batch and if there is only one item in the batch
        val isNotLastItemInTheBatch = index != contexts.size - 1
        if (isNotLastItemInTheBatch && (contexts.size > 1 || isAlwaysBatch)) statement.addBatch()
    }
    if (!transaction.db.supportsMultipleResultSets) {
        transaction.closeExecutedStatements()
    }

    transaction.currentStatement = statement
    transaction.interceptors.forEach { it.afterStatementPrepared(transaction, statement) }
    val result = try {
        statement.executeInternal(transaction)
    } catch (cause: R2dbcException) {
        throw ExposedR2dbcException(cause, contexts, transaction)
    }
    transaction.currentStatement = null
    transaction.executedStatements.add(statement)

    R2dbcTransaction.globalInterceptors.forEach { it.afterExecution(transaction, contexts, statement) }
    transaction.interceptors.forEach { it.afterExecution(transaction, contexts, statement) }
    return result to contexts
}
