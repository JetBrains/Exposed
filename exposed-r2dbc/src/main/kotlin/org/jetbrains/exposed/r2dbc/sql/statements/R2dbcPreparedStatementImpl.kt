package org.jetbrains.exposed.r2dbc.sql.statements

import io.r2dbc.spi.Connection
import io.r2dbc.spi.Statement
import kotlinx.coroutines.flow.toList
import kotlinx.coroutines.reactive.awaitFirstOrNull
import org.jetbrains.exposed.r2dbc.sql.mappers.TypeMapperRegistry
import org.jetbrains.exposed.r2dbc.sql.statements.api.R2dbcPreparedStatementApi
import org.jetbrains.exposed.r2dbc.sql.statements.api.R2dbcResult
import org.jetbrains.exposed.sql.*
import org.jetbrains.exposed.sql.statements.StatementResult
import org.jetbrains.exposed.sql.vendors.DatabaseDialect
import java.io.InputStream
import java.time.Duration

/**
 * Class representing a precompiled SQL [Statement] from the R2DBC SPI.
 *
 * The result row generated by executing this statement contains auto-generated keys based on the value of
 * [wasGeneratedKeysRequested].
 */
class R2dbcPreparedStatementImpl(
    private val statement: Statement,
    // the property below is only here for setTimeout() --> should this logic be in R2dbcConnectionImpl instead
    val connection: Connection,
    val wasGeneratedKeysRequested: Boolean,
    private val currentDialect: DatabaseDialect,
    private val typeMapperRegistry: TypeMapperRegistry
) : R2dbcPreparedStatementApi {
    private var resultRow: R2dbcResult? = null

    override suspend fun getResultRow(): R2dbcResult? {
        if (resultRow == null && wasGeneratedKeysRequested) {
            val resultPublisher = statement.execute()
            resultRow = R2dbcResult(resultPublisher)
        }

        return resultRow
    }

    override suspend fun setFetchSize(value: Int?) {
        value?.let { statement.fetchSize(value) }
    }

    override suspend fun setTimeout(value: Int?) {
        value?.let {
            connection.setStatementTimeout(Duration.ofSeconds(value.toLong())).awaitFirstOrNull()
        }
    }

    override suspend fun addBatch() {
        statement.add()
    }

    override suspend fun executeQuery(): R2dbcResult = R2dbcResult(statement.execute())

    override suspend fun executeUpdate(): Int {
        val result = statement.execute()
        val r2dbcResult = R2dbcResult(result)
        resultRow = r2dbcResult

        // Todo discuss if a return value is even necessary (since never used)
        return 0
    }

    override suspend fun executeMultiple(): List<StatementResult> {
        val result = statement.execute()
        val r2dbcResult = R2dbcResult(result)
        return listOf(StatementResult.Object(r2dbcResult))
        // full JDBC logic does not seem possible here
//        return if (statement.execute()) {
//            listOf(StatementResult.Object(JdbcResult(statement.resultSet)))
//        } else {
//            // getMoreResults() returns true only if next result is a ResultSet
//            while (!statement.getMoreResults(Statement.CLOSE_CURRENT_RESULT)) {
//                if (statement.updateCount == -1) return emptyList()
//            }
//            listOf(StatementResult.Object(JdbcResult(statement.resultSet)))
//        }
    }

    override fun set(index: Int, value: Any) {
        // Try to use the type mappers first
        // We use VarCharColumnType as a placeholder since we don't have a real column type
        if (typeMapperRegistry.setValue(statement, currentDialect, VarCharColumnType(), value, index)) {
            return
        }

        throw IllegalArgumentException("Unsupported value type: ${value::class.qualifiedName}")
    }

    override fun setNull(index: Int, columnType: IColumnType<*>) {
        // Try to use the type mappers first
        if (typeMapperRegistry.setValue(statement, currentDialect, columnType, null, index)) {
            return
        }

        throw IllegalArgumentException("Unsupported column type for null value: ${columnType::class.qualifiedName}")
    }

    override fun setInputStream(index: Int, inputStream: InputStream, setAsBlobObject: Boolean) {
        val columnType = if (setAsBlobObject) BlobColumnType() else BinaryColumnType(Int.MAX_VALUE)
        if (typeMapperRegistry.setValue(statement, currentDialect, columnType, inputStream, index)) {
            return
        }

        throw IllegalArgumentException("Unsupported InputStream for column type: ${columnType::class.qualifiedName}")
    }

    override fun setArray(index: Int, arrayType: ArrayColumnType<*, *>, array: Array<*>) {
        // Try to use the type mappers first
        if (typeMapperRegistry.setValue(statement, currentDialect, arrayType, array, index)) {
            return
        }

        throw IllegalArgumentException("Unsupported array type: ${arrayType::class.qualifiedName}")
    }

    override suspend fun closeIfPossible() {
        // do nothing
    }

    override suspend fun executeBatch(): List<Int> {
        val result = statement.execute()
        val r2dbcResult = R2dbcResult(result)

        return if (wasGeneratedKeysRequested) {
            resultRow = r2dbcResult
            emptyList()
        } else {
            resultRow = null
            r2dbcResult.rowsUpdated().toList()
        }
    }

    override suspend fun cancel() {
        // do nothing
    }
}
