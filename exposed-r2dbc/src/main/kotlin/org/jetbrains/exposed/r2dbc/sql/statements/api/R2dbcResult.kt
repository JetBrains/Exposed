package org.jetbrains.exposed.r2dbc.sql.statements.api

import io.r2dbc.spi.Result
import io.r2dbc.spi.Row
import io.r2dbc.spi.RowMetadata
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.count
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.reactive.asFlow
import kotlinx.coroutines.reactive.asPublisher
import kotlinx.coroutines.reactive.awaitFirstOrNull
import kotlinx.coroutines.reactive.collect
import org.jetbrains.exposed.sql.statements.api.ResultApi
import org.jetbrains.exposed.sql.statements.api.RowApi
import org.reactivestreams.Publisher

suspend fun R2dbcResult(resultPublisher: Publisher<out Result>): R2dbcResult {
    val result = resultPublisher.awaitFirstOrNull() ?: error("No result found")
    return R2dbcResult(result)
}

/**
 * Class for wrapping an [Row] generated by executing a statement that queries an R2DBC database.
 *
 * @property resultPublisher The actual [Result] returned by the database after statement execution.
 */
class R2dbcResult internal constructor(
    private val result: Result
) : ResultApi {
    private var consumed = false

    override fun <T> mapRows(block: (RowApi) -> T): Flow<T> {
        if (consumed) error("Result is already consumed")
        consumed = true

        return flow {
            result.map { row, rm ->
                block(R2DBCRow(row))
            }.collect { emit(it) }
        }
    }

    fun <T : Any> mapSegments(block: (Result.Segment) -> Flow<T>): Flow<T> = result.flatMap<T> {
        val result = block(it)
        result.asPublisher()
    }.asFlow()

    override fun toString(): String = "R2dbcResult(result = $result)"

    override fun close() = Unit
}

@JvmInline
value class R2DBCRow(val row: Row) : RowApi {
    override fun getObject(index: Int): Any? = row.get(index - 1)

    override fun getObject(name: String): Any? = row.get(name)

    override fun <T> getObject(index: Int, type: Class<T>): T? = row.get(index - 1, type)

    override fun <T> getObject(name: String, type: Class<T>): T? = row.get(name, type)
}

suspend fun ResultApi.rowsCount() = mapRows { }.count()

val RowApi.origin: Row get() = (this as R2DBCRow).row

val RowApi.metadata: RowMetadata get() = (this as R2DBCRow).row.metadata
