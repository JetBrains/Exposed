package org.jetbrains.exposed.r2dbc.sql.statements.api

import io.r2dbc.postgresql.codec.Json
import io.r2dbc.spi.Result
import io.r2dbc.spi.Row
import io.r2dbc.spi.RowMetadata
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.collect
import kotlinx.coroutines.flow.count
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.reactive.asPublisher
import kotlinx.coroutines.reactive.collect
import org.jetbrains.exposed.sql.statements.api.ResultApi
import org.jetbrains.exposed.sql.statements.api.RowApi
import org.reactivestreams.Publisher
import java.sql.Date
import java.sql.Time
import java.sql.Timestamp
import java.time.LocalDate
import java.time.LocalDateTime
import java.time.LocalTime
import java.util.*
import kotlin.jvm.optionals.getOrNull

/**
 * Class for wrapping an [Row] generated by executing a statement that queries an R2DBC database.
 *
 * @property resultPublisher The actual [Result] returned by the database after statement execution.
 */
class R2dbcResult internal constructor(
    private val resultPublisher: Publisher<out Result>
) : ResultApi {
    private var consumed = false

    override fun <T> mapRows(block: (RowApi) -> T?): Flow<T?> {
        if (consumed) error("Result is already consumed")
        consumed = true

        return flow {
            resultPublisher.collect { result ->
                result.map { row, rm ->
                    Optional.ofNullable(block(R2DBCRow(row)))
                }.collect { emit(it.getOrNull()) }
            }
        }
    }

    fun <T : Any> mapSegments(block: (Result.Segment) -> Flow<T>): Flow<T> = flow {
        resultPublisher.collect { result ->
            result.flatMap<T> { segment ->
                val rf = block(segment)
                rf.asPublisher()
            }.collect { emit(it) }
        }
    }

    // Todo relies on rowsUpdated throwing ISE if already consumed; should we fail earlier as in mapRows()?
    fun rowsUpdated(): Flow<Int> = flow {
        resultPublisher.collect { result ->
            result.rowsUpdated.collect { count ->
                emit(count.toInt())
            }
        }
    }

    // terminal operation to trigger final collection of flow, but ignore emitting values
    suspend fun collect() {
        mapRows { }.collect()
    }

    override fun toString(): String = "R2dbcResult(resultPublisher = $resultPublisher)"

    override fun close() = Unit
}

@JvmInline
value class R2DBCRow(val row: Row) : RowApi {
    override fun getObject(index: Int): Any? {
        val result = row.get(index - 1)
        return when (result) {
            is Json -> result.asString()
            else -> result
        }
    }

    override fun getObject(name: String): Any? = row.get(name)

    override fun <T> getObject(index: Int, type: Class<T>): T? = when (type) {
        Time::class.java -> {
            val result: LocalTime? = row.get(index - 1, LocalTime::class.java) ?: return null
            @Suppress("UNCHECKED_CAST")
            Time.valueOf(result) as T
        }
        Date::class.java -> {
            val result: LocalDate? = row.get(index - 1, LocalDate::class.java) ?: return null
            @Suppress("UNCHECKED_CAST")
            Date.valueOf(result) as T
        }
        Timestamp::class.java -> {
            val result: LocalDateTime? = row.get(index - 1, LocalDateTime::class.java) ?: return null
            @Suppress("UNCHECKED_CAST")
            Timestamp.valueOf(result) as T
        }
        else -> row.get(index - 1, type) as T
    }

    override fun <T> getObject(name: String, type: Class<T>): T? = row.get(name, type)
}

suspend fun ResultApi.rowsCount() = mapRows { }.count()

val RowApi.origin: Row get() = (this as R2DBCRow).row

val RowApi.metadata: RowMetadata get() = (this as R2DBCRow).row.metadata
