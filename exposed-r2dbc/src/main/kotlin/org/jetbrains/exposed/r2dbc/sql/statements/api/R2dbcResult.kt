package org.jetbrains.exposed.r2dbc.sql.statements.api

import io.r2dbc.spi.Result
import io.r2dbc.spi.Row
import io.r2dbc.spi.RowMetadata
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.reactive.awaitFirstOrNull
import kotlinx.coroutines.reactive.collect
import org.jetbrains.exposed.sql.statements.api.ResultApi
import org.jetbrains.exposed.sql.statements.api.RowApi
import org.reactivestreams.Publisher

suspend fun R2dbcResult(resultPublisher: Publisher<out Result>): R2dbcResult {
    val result = resultPublisher.awaitFirstOrNull() ?: error("No result found")
    return R2dbcResult(result)
}

/**
 * Class for wrapping an [Row] generated by executing a statement that queries an R2DBC database.
 *
 * @property resultPublisher The actual [Result] returned by the database after statement execution.
 */
class R2dbcResult internal constructor(
    private val result: Result
) : ResultApi {
    private var consumed = false

    override fun rows(): Flow<R2dbcRecord> {
        if (consumed) error("Result is already consumed")
        consumed = true

        return flow {
            result.map { row, rm ->
                R2dbcRecord(row)
            }.collect { emit(it) }
        }
    }

    override fun toString(): String = "R2dbcResult(result = $result)"

    override fun close() = Unit

    class R2dbcRecord(val row: Row) : RowApi {
        val metadata: RowMetadata get() = row.metadata
        override fun getObject(index: Int): Any? = row.get(index - 1)

        override fun getObject(name: String): Any? = row.get(name)

        override fun <T> getObject(index: Int, type: Class<T>): T? = row.get(index - 1, type)

        override fun <T> getObject(name: String, type: Class<T>): T? = row.get(name, type)
    }
}
