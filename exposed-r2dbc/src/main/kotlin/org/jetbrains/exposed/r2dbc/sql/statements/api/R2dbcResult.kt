package org.jetbrains.exposed.r2dbc.sql.statements.api

import io.r2dbc.spi.Result
import io.r2dbc.spi.Row
import io.r2dbc.spi.RowMetadata
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.collect
import kotlinx.coroutines.flow.count
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.reactive.asPublisher
import kotlinx.coroutines.reactive.collect
import org.jetbrains.exposed.sql.statements.api.ResultApi
import org.jetbrains.exposed.sql.statements.api.RowApi
import org.reactivestreams.Publisher
import java.sql.Timestamp
import java.time.LocalDateTime

/**
 * Class for wrapping an [Row] generated by executing a statement that queries an R2DBC database.
 *
 * @property resultPublisher The actual [Result] returned by the database after statement execution.
 */
class R2dbcResult internal constructor(
    private val resultPublisher: Publisher<out Result>
) : ResultApi {
    private var consumed = false

    override fun <T> mapRows(block: (RowApi) -> T): Flow<T> {
        if (consumed) error("Result is already consumed")
        consumed = true

        return flow {
            resultPublisher.collect { result ->
                result.map { row, rm ->
                    block(R2DBCRow(row))
                }.collect { emit(it) }
            }
        }
    }

    fun <T : Any> mapSegments(block: (Result.Segment) -> Flow<T>): Flow<T> = flow {
        resultPublisher.collect { result ->
            result.flatMap<T> { segment ->
                val rf = block(segment)
                rf.asPublisher()
            }.collect { emit(it) }
        }
    }

    // Todo relies on rowsUpdated throwing ISE if already consumed; should we fail earlier as in mapRows()?
    fun rowsUpdated(): Flow<Int> = flow {
        resultPublisher.collect { result ->
            result.rowsUpdated.collect { count ->
                emit(count.toInt())
            }
        }
    }

    // terminal operation to trigger final collection of flow, but ignore emitting values
    suspend fun collect() {
        mapRows { }.collect()
    }

    override fun toString(): String = "R2dbcResult(resultPublisher = $resultPublisher)"

    override fun close() = Unit
}

@JvmInline
value class R2DBCRow(val row: Row) : RowApi {
    override fun getObject(index: Int): Any? = row.get(index - 1)

    override fun getObject(name: String): Any? = row.get(name)

    override fun <T> getObject(index: Int, type: Class<T>): T? = when (type) {
        Timestamp::class.java -> {
            val result: LocalDateTime? = row.get(index - 1, LocalDateTime::class.java) ?: return null
            @Suppress("UNCHECKED_CAST")
            Timestamp.valueOf(result) as T
        }
        else -> row.get(index - 1, type) as T
    }

    override fun <T> getObject(name: String, type: Class<T>): T? = row.get(name, type)
}

suspend fun ResultApi.rowsCount() = mapRows { }.count()

val RowApi.origin: Row get() = (this as R2DBCRow).row

val RowApi.metadata: RowMetadata get() = (this as R2DBCRow).row.metadata
