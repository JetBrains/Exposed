package org.jetbrains.exposed.sql.statements

import org.jetbrains.exposed.exceptions.ExposedSQLException
import org.jetbrains.exposed.sql.InternalApi
import org.jetbrains.exposed.sql.R2dbcTransaction
import org.jetbrains.exposed.sql.statements.api.R2dbcPreparedStatementApi
import java.sql.SQLException

internal object DefaultValueMarker {
    override fun toString(): String = "DEFAULT"
}

interface SuspendExecutable<out T, S : Statement<T>> {
    val statement: S

    /**
     * Determines the exact way that an SQL statement is executed in a [transaction] and applies any necessary
     * logic before returning the result generated by the executed statement.
     */
    suspend fun R2dbcPreparedStatementApi.executeInternal(transaction: R2dbcTransaction): T?

    /**
     * Uses a [transaction] connection and an [sql] string representation to return a precompiled SQL statement,
     * stored as an implementation of [PreparedStatementApi].
     */
    suspend fun prepared(
        transaction: R2dbcTransaction,
        sql: String
    ): R2dbcPreparedStatementApi = transaction.connection.prepareStatement(sql, false)

    /** Whether the SQL statement is meant to be performed as part of a batch execution. */
    val isAlwaysBatch: Boolean
        get() = false

    /**
     * Executes the SQL statement directly in the provided [transaction] and returns the generated result,
     * or `null` if either no result was retrieved or if the transaction blocked statement execution.
     */
    suspend fun execute(transaction: R2dbcTransaction): T? {
        return if (transaction.blockStatementExecution) {
            transaction.explainStatement = statement
            null
        } else {
            transaction.exec(this)
        }
    }
}

@OptIn(InternalApi::class)
internal suspend fun <T, S : Statement<T>> SuspendExecutable<T, S>.executeIn(
    transaction: R2dbcTransaction
): Pair<T?, List<StatementContext>> {
    val arguments = statement.arguments()
    val contexts = if (arguments.any()) {
        arguments.map { args ->
            val context = StatementContext(statement, args)
            R2dbcTransaction.globalInterceptors.forEach { it.beforeExecution(transaction, context) }
            transaction.interceptors.forEach { it.beforeExecution(transaction, context) }
            context
        }
    } else {
        val context = StatementContext(statement, emptyList())
        R2dbcTransaction.globalInterceptors.forEach { it.beforeExecution(transaction, context) }
        transaction.interceptors.forEach { it.beforeExecution(transaction, context) }
        listOf(context)
    }

    val statement = try {
        prepared(transaction, statement.prepareSQL(transaction)).apply {
            setTimeout(transaction.queryTimeout)
        }
    } catch (e: SQLException) {
        throw ExposedSQLException(e, contexts, transaction)
    }
    contexts.forEachIndexed { _, context ->
        statement.fillParameters(context.args)
        // REVIEW
        if (contexts.size > 1 || isAlwaysBatch) statement.addBatch()
    }
    if (!transaction.db.supportsMultipleResultSets) {
        transaction.closeExecutedStatements()
    }

    transaction.currentStatement = statement
    transaction.interceptors.forEach { it.afterStatementPrepared(transaction, statement) }
    val result = try {
        statement.executeInternal(transaction)
    } catch (cause: SQLException) {
        throw ExposedSQLException(cause, contexts, transaction)
    }
    transaction.currentStatement = null
    transaction.executedStatements.add(statement)

    R2dbcTransaction.globalInterceptors.forEach { it.afterExecution(transaction, contexts, statement) }
    transaction.interceptors.forEach { it.afterExecution(transaction, contexts, statement) }
    return result to contexts
}
