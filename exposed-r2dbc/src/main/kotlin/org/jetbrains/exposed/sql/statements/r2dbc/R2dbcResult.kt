package org.jetbrains.exposed.sql.statements.r2dbc

import io.r2dbc.spi.Readable
import io.r2dbc.spi.Result
import io.r2dbc.spi.Row
import io.r2dbc.spi.RowMetadata
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.reactive.awaitFirstOrNull
import kotlinx.coroutines.reactive.collect
import org.jetbrains.exposed.sql.statements.api.ResultApi
import org.jetbrains.exposed.sql.statements.api.RowApi
import org.reactivestreams.Publisher

/**
 * Class for wrapping an [io.r2dbc.spi.Row] generated by executing a statement that queries an R2DBC database.
 *
 * @property resultPublisher The actual [Result] returned by the database after statement execution.
 */
class R2dbcResult(
    private val resultPublisher: Publisher<out Result>
) : ResultApi {
    private var awaitedResult: Result? = null

    suspend fun result(): Result {
        return awaitedResult ?: resultPublisher.awaitFirstOrNull() ?: error("No result found")
    }

    override fun rows(): Flow<R2dbcRecord> = flow {
        // Extra flow is created to avoid suspending [rows] method.
        result().map { row, rm ->
            R2dbcRecord(row, rm)
        }.collect { emit(it) }
    }

    override fun toString(): String = "R2dbcResult(result = $resultPublisher)"

    override fun close() = Unit

    class R2dbcRecord(val row: Row, val metadata: RowMetadata) : RowApi by row.toRowApi()
}

private fun Readable.toRowApi(): RowApi = object : RowApi {
    override fun getObject(index: Int): Any? {
        return this@toRowApi.get(index)
    }

    override fun getObject(name: String): Any? {
        return this@toRowApi.get(name)
    }

    override fun <T> getObject(index: Int, type: Class<T>): T? {
        return this@toRowApi.get(index, type)
    }

    override fun <T> getObject(name: String, type: Class<T>): T? {
        return this@toRowApi.get(name, type)
    }
}
