package org.jetbrains.exposed.sql.statements.r2dbc

import io.r2dbc.spi.Connection
import io.r2dbc.spi.Parameters
import io.r2dbc.spi.R2dbcType
import io.r2dbc.spi.Statement
import kotlinx.coroutines.reactive.awaitFirstOrNull
import org.jetbrains.exposed.sql.*
import org.jetbrains.exposed.sql.statements.api.R2dbcPreparedStatementApi
import java.io.InputStream
import java.math.BigDecimal
import java.time.Duration
import java.util.*

/**
 * Class representing a precompiled SQL [Statement] from the R2DBC SPI.
 *
 * The result row generated by executing this statement contains auto-generated keys based on the value of
 * [wasGeneratedKeysRequested].
 */
class R2dbcPreparedStatementImpl(
    val statement: Statement,
    // the property below is only here for setTimeout() --> should this logic be in R2dbcConnectionImpl instead
    val connection: Connection,
    val wasGeneratedKeysRequested: Boolean
) : R2dbcPreparedStatementApi {
    private var resultRow: R2dbcResult? = null

    override suspend fun getResultRow(): R2dbcResult? = resultRow

    override suspend fun setFetchSize(value: Int?) {
        value?.let { statement.fetchSize(value) }
    }

    override suspend fun setTimeout(value: Int?) {
        value?.let { connection.setStatementTimeout(Duration.ofSeconds(value.toLong())) }
    }

    override suspend fun addBatch() {
        // unlike JDBC, a differentiation may need to be made between Statement and Batch objects
        statement.add() // REVIEW potential preceding operation, bind()
    }

    override suspend fun executeQuery(): R2dbcResult = R2dbcResult(statement.execute())

    override suspend fun executeUpdate(): Int {
        val result = statement.execute()
        resultRow = R2dbcResult(result)
        return result.awaitFirstOrNull()?.rowsUpdated?.awaitFirstOrNull()?.toInt() ?: 0
    }

    override fun set(index: Int, value: Any) {
        statement.bind(index - 1, value)
    }

    override fun setNull(index: Int, columnType: IColumnType<*>) {
        val columnValueType = when (columnType) {
            is EntityIDColumnType<*> -> {
                setNull(index, columnType.idColumn.columnType)
                return
            }
            is ColumnWithTransform<*, *> -> {
                setNull(index, columnType.delegate)
                return
            }
            is ByteColumnType -> Byte::class.java
            is UByteColumnType -> UByte::class.java
            is ShortColumnType -> Short::class.java
            is UShortColumnType -> UShort::class.java
            is IntegerColumnType -> Integer::class.java
            is UIntegerColumnType -> UInt::class.java
            is LongColumnType -> Long::class.java
            is ULongColumnType -> ULong::class.java
            is FloatColumnType -> Float::class.java
            is DoubleColumnType -> Double::class.java
            is DecimalColumnType -> BigDecimal::class.java
            is BasicBinaryColumnType, is BlobColumnType -> ByteArray::class.java
            is UUIDColumnType -> UUID::class.java
            is CharacterColumnType -> Char::class.java
            is BooleanColumnType -> Boolean::class.java
            is ArrayColumnType<*, *> -> List::class.java
            else -> String::class.java
        }
        statement.bindNull(index - 1, columnValueType)
    }

    override fun setInputStream(index: Int, inputStream: InputStream, setAsBlobObject: Boolean) {
        if (setAsBlobObject) {
            statement.bind(index - 1, Parameters.`in`(R2dbcType.BLOB, inputStream.readBytes()))
        } else {
            statement.bind(index - 1, Parameters.`in`(R2dbcType.VARBINARY, inputStream.readBytes()))
        }
    }

    override fun setArray(index: Int, type: String, array: Array<*>) {
        statement.bind(index - 1, Parameters.`in`(R2dbcType.COLLECTION, array))
    }

    override suspend fun closeIfPossible() {
        // do nothing
    }

    override suspend fun executeBatch(): List<Int> {
        // unlike JDBC, a differentiation may need to be made between Statement and Batch objects
        return emptyList()
    }

    override suspend fun cancel() {
        // do nothing
    }
}
