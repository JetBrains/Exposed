<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd"
       id="Data-Types" title="Data Types">

    <show-structure for="chapter,procedure" depth="3"/>
    <p>Exposed supports the following data types in the table definition:</p>
    <list>
        <li><code>integer</code> - translates to DB <code>INT</code></li>
        <li><code>short</code> - translates to DB <code>SMALLINT</code></li>
        <li><code>long</code> - <code>BIGINT</code></li>
        <li><code>float</code> - <code>FLOAT</code></li>
        <li><code>decimal</code> - <code>DECIMAL</code> with scale and precision</li>
        <li><code>bool</code> - <code>BOOLEAN</code></li>
        <li><code>char</code> - <code>CHAR</code></li>
        <li><code>varchar</code> - <code>VARCHAR</code> with length</li>
        <li><code>text</code> - <code>TEXT</code></li>
        <li><code>enumeration</code> - <code>INT</code> ordinal value</li>
        <li><code>enumerationByName</code> - <code>VARCHAR</code></li>
        <li><code>customEnumeration</code> - see <a anchor="how-to-use-database-enum-types">additional section</a></li>
        <li><code>blob</code> - <code>BLOB</code></li>
        <li><code>binary</code> - <code>VARBINARY</code> with length</li>
        <li><code>uuid</code> - <code>BINARY(16)</code></li>
        <li><code>reference</code> - a foreign key</li>
        <li><code>array</code> - <code>ARRAY</code></li>
    </list>
    <p>The <code>exposed-java-time</code> extension
        (<code>org.jetbrains.exposed:exposed-java-time:$exposed_version</code>) provides additional types:</p>
    <list>
        <li><code>date</code> - <code>DATETIME</code></li>
        <li><code>time</code> - <code>TIME</code></li>
        <li><code>datetime</code> - <code>DATETIME</code></li>
        <li><code>timestamp</code> - <code>TIMESTAMP</code></li>
        <li><code>duration</code> - <code>DURATION</code></li>
    </list>
    <note>
        Some types are different for specific DB dialect.
    </note>
    <p>The <code>exposed-json</code> extension (<code>org.jetbrains.exposed:exposed-json:$exposed_version</code>)
        provides additional types
        (see <a anchor="how-to-use-json-and-jsonb-types">how to use</a>):</p>
    <list>
        <li><code>json</code> - <code>JSON</code></li>
        <li><code>jsonb</code> - <code>JSONB</code></li>
    </list>
    <note>
        Databases store JSON values either in text or binary format, so Exposed provides two types to account for any
        potential
        differences, if they exist, for example:
        <list>
            <li>
                <control>PostgreSQL</control>
                : <code>json()</code> maps to <code>JSON</code>, while <code>jsonb()</code> maps to <code>JSONB</code>.
            </li>
            <li>
                <control>SQLite</control>
                : No native JSON type, so <code>json()</code> maps to TEXT, while <code>jsonb()</code> throws.
            </li>
            <li>
                <control>MySQL</control>
                : JSON type only supports binary format, so <code>json()</code> and <code>jsonb()</code> both map to
                JSON.
            </li>
            <li>
                <control>Oracle</control>
                : Exposed does not currently support the JSON binary format of Oracle 21c; only text format
                <code>json()</code> can be used.
            </li>
        </list>
    </note>
    <chapter title="How to use database ENUM types" id="how-to-use-database-enum-types">
        <p>Some of the databases (e.g. MySQL, PostgreSQL, H2) support explicit ENUM types. Because keeping such columns
            in sync with
            Kotlin enumerations using only JDBC metadata could be a huge challenge, Exposed doesn't provide a
            possibility to manage
            such columns in an automatic way, but that doesn't mean that you can't use such column types.</p>
        <p>You have two options to work with ENUM database types and you should use <code>customEnumeration()</code>
            (available since version 0.10.3) in both cases:</p>
        <list type="decimal">
            <li>Use an existing ENUM column from your table. In this case, the <code>sql</code> parameter in <code>customEnumeration()</code>
                can be left as <code>null</code>.
            </li>
            <li>Create a new ENUM column using Exposed by providing the raw definition SQL to the <code>sql</code>
                parameter in <code>customEnumeration()</code>.
            </li>
        </list>
        <p>As a JDBC driver can provide/expect specific classes for ENUM types, you must also provide from/to
            transformation functions for
            them when defining a <code>customEnumeration</code>.</p>
        <p>For a class like <code>enum class Foo { BAR, BAZ }</code>, you can use the provided code below for your
            specific database:</p>
        <chapter title="MySQL, H2" id="mysql-h2">

            <code-block lang="Kotlin">
                val existingEnumColumn = customEnumeration("enumColumn", { value -> Foo.valueOf(value as String) }, { it.name })
                val newEnumColumn = customEnumeration("enumColumn", "ENUM('BAR', 'BAZ')", { value -> Foo.valueOf(value as String) }, { it.name })
            </code-block>
        </chapter>
        <chapter title="PostgreSQL" id="postgresql">
            <p>PostgreSQL requires that ENUM is defined as a separate type, so you have to create it before creating
                your table.
                Also, the PostgreSQL JDBC driver returns <code>PGobject</code> instances for such values, so a <code>PGobject</code>
                with its type manually set to the ENUM type needs to be used for the <code>toDb</code> parameter.
                The full working sample is provided below:</p>

            <code-block lang="Kotlin"><![CDATA[
                class PGEnum<T : Enum<T>>(enumTypeName: String, enumValue: T?) : PGobject() {
                    init {
                        value = enumValue?.name
                        type = enumTypeName
                    }
                }

                object EnumTable : Table() {
                    val enumColumn = customEnumeration("enumColumn", "FooEnum", { value -> Foo.valueOf(value as String) }, { PGEnum("FooEnum", it) })
                }

                transaction {
                    exec("CREATE TYPE FooEnum AS ENUM ('BAR', 'BAZ');")
                    SchemaUtils.create(EnumTable)
                }
            ]]></code-block>
        </chapter>
    </chapter>
    <chapter title="How to use Json and JsonB types" id="how-to-use-json-and-jsonb-types">
        <p>Add the following dependencies to your <code>build.gradle.kts</code>:</p>

        <code-block lang="kotlin">
            val exposedVersion: String by project

            dependencies {
                implementation("org.jetbrains.exposed:exposed-core:$exposedVersion")
                implementation("org.jetbrains.exposed:exposed-json:$exposedVersion")
            }
        </code-block>
        <p>Exposed works together with the JSON serialization/deserialization library of your choice by allowing column
            definitions
            that accept generic serializer and deserializer arguments:</p>

        <code-block lang="kotlin"><![CDATA[
            fun <T : Any> json(name: String, serialize: (T) -> String, deserialize: (String) -> T): Column<T>

            fun <T : Any> jsonb(name: String, serialize: (T) -> String, deserialize: (String) -> T): Column<T>
        ]]></code-block>
        <p>Here's an example that leverages <a href="https://github.com/Kotlin/kotlinx.serialization">kotlinx.serialization</a>
            to support
            <code>@Serializable</code> classes. It uses a simpler form of <code>json()</code> that relies on the
            library's <code>KSerializer</code> interface:</p>

        <code-block lang="kotlin"><![CDATA[
            @Serializable
            data class Project(val name: String, val language: String, val active: Boolean)

            val format = Json { prettyPrint = true }

            object Teams : Table("team") {
                val groupId = varchar("group_id", 32)
                val project = json<Project>("project", format) // equivalent to json("project", format, Project.serializer())
            }

            transaction {
                val mainProject = Project("Main", "Java", true)
                Teams.insert {
                    it[groupId] = "A"
                    it[project] = mainProject
                }
                Teams.update({ Teams.groupId eq "A" }) {
                    it[project] = mainProject.copy(language = "Kotlin")
                }

                Teams.selectAll().map { "Team ${it[Teams.groupId]} -> ${it[Teams.project]}" }.forEach { println(it) }
                // Team A -> Project(name=Main, language=Kotlin, active=true)
            }
        ]]></code-block>
        <p>Here's how the same <code>Project</code> and <code>Teams</code> would be defined using <a
                href="https://github.com/FasterXML/jackson">Jackson</a>
            with the <code>jackson-module-kotlin</code> dependency and the full form of <code>json()</code>:</p>

        <code-block lang="kotlin"><![CDATA[
            val mapper = jacksonObjectMapper()

            data class Project(val name: String, val language: String, val active: Boolean)

            object Teams : Table("team") {
                val groupId = varchar("group_id", 32)
                val project = json("project", { mapper.writeValueAsString(it) }, { mapper.readValue<Project>(it) })
            }
        ]]></code-block>
        <chapter title="Json Functions" id="json-functions">
            <p>JSON path strings can be used to extract values (either as JSON or as a scalar value) at a specific
                field/key:</p>

            <code-block lang="kotlin"><![CDATA[
                val projectName = Teams.project.extract<String>("name")
                val languageIsKotlin = Teams.project.extract<String>("language").lowerCase() eq "kotlin"
                Teams.select(projectName).where { languageIsKotlin }.map { it[projectName] }
            ]]></code-block>
            <note>
                Databases that support a path context root <code>$</code> will have this value appended to the generated
                SQL path expression
                by default, so it is not necessary to include it in the provided argument String. In the above example,
                if MySQL is being
                used, the provided path arguments should be <code>.name</code> and <code>.language</code> respectively.
            </note>
            <p>The JSON functions <code>exists()</code> and <code>contains()</code> are currently supported as well:</p>

            <code-block lang="kotlin">
                val hasActiveStatus = Teams.project.exists(".active")
                val activeProjects = Teams.selectAll().where { hasActiveStatus }.count()

                // Depending on the database, filter paths can be provided instead, as well as optional arguments
                // PostgreSQL example
                val mainId = "Main"
                val hasMainProject = Teams.project.exists(".name ? (@ == \$main)", optional = "{\"main\":\"$mainId\"}")
                val mainProjects = Teams.selectAll().where { hasMainProject }.map { it[Teams.groupId] }

                val usesKotlin = Teams.project.contains("{\"language\":\"Kotlin\"}")
                val kotlinTeams = Teams.selectAll().where { usesKotlin }.count()

                // Depending on the database, an optional path can be provided too
                // MySQL example
                val usesKotlin = Teams.project.contains("\"Kotlin\"", ".language")
                val kotlinTeams = Teams.selectAll().where { usesKotlin }.count()
            </code-block>
        </chapter>
        <chapter title="Json Arrays" id="json-arrays">
            <p>JSON columns also accept JSON arrays as input values. For example, using the serializable data class
                <code>Project</code> from the
                example above, the following details some ways to create such a column:</p>

            <code-block lang="kotlin"><![CDATA[
                object TeamProjects : Table("team_projects") {
                    val memberIds = json<IntArray>("member_ids", Json.Default)
                    val projects = json<Array<Project>>("projects", Json.Default)
                    // equivalent to:
                    // @OptIn(ExperimentalSerializationApi::class) json("projects", Json.Default, ArraySerializer(Project.serializer()))
                }

                transaction {
                    TeamProjects.insert {
                        it[memberIds] = intArrayOf(1, 2, 3)
                        it[projects] = arrayOf(
                            Project("A", "Kotlin", true),
                            Project("B", "Java", true)
                        )
                    }
                    // generates SQL
                    // INSERT INTO team_projects (member_ids, projects) VALUES ([1,2,3], [{"name":"A","language":"Kotlin","active":true},{"name":"B","language":"Java","active":true}])
                }
            ]]></code-block>
        </chapter>
    </chapter>
    <chapter title="How to use Array types" id="how-to-use-array-types">
        <p>PostgreSQL and H2 databases support the explicit ARRAY data type.</p>
        <p>Exposed currently only supports columns defined as one-dimensional arrays, with the stored contents being any
            out-of-the-box or custom data type.
            If the contents are of a type with a supported <code>ColumnType</code> in the <code>exposed-core</code>
            module, the column can be simply defined with that type:</p>

        <code-block lang="kotlin">
            object Teams : Table(&quot;teams&quot;) {
                val memberIds = array&lt;UUID&gt;(&quot;member_ids&quot;)
                val memberNames = array&lt;String&gt;(&quot;member_names&quot;)
                val budgets = array&lt;Double&gt;(&quot;budgets&quot;)
            }
        </code-block>
        <p>If more control is needed over the base content type, or if the latter is user-defined or from a non-core
            module, the explicit type should be provided to the function:</p>

        <code-block lang="kotlin">
            object Teams : Table(&quot;teams&quot;) {
                val memberIds = array&lt;UUID&gt;(&quot;member_ids&quot;)
                val memberNames = array&lt;String&gt;(&quot;member_names&quot;, VarCharColumnType(colLength = 32))
                val deadlines = array&lt;LocalDate&gt;(&quot;deadlines&quot;, KotlinLocalDateColumnType()).nullable()
                val budgets = array&lt;Double&gt;(&quot;budgets&quot;)
                val expenses = array&lt;Double?&gt;(&quot;expenses&quot;, DoubleColumnType()).default(emptyList())
            }
        </code-block>
        <p>This will prevent an exception being thrown if Exposed cannot find an associated column mapping for the
            defined type.
            Null array contents are allowed, and the explicit column type should be provided for these columns as
            well.</p>
        <p>An array column accepts inserts and retrieves stored array contents as a Kotlin <code>List</code>:</p>

        <code-block lang="kotlin">
            Teams.insert {
                it[memberIds] = List(5) { UUID.randomUUID() }
                it[memberNames] = List(5) { i -&gt; &quot;Member ${'A' + i}&quot; }
                it[budgets] = listOf(9999.0)
            }
        </code-block>
        <chapter title="Array Functions" id="array-functions">
            <p>A single element in a stored array can be accessed using the index reference <code>get()</code> operator:
            </p>

            <code-block lang="kotlin">
                val firstMember = Teams.memberIds[1]
                Teams
                    .select(firstMember)
                    .where { Teams.expenses[1] greater Teams.budgets[1] }
            </code-block>
            <note>
                Both PostgreSQL and H2 use a one-based indexing convention, so the first element is retrieved by using
                index 1.
            </note>
            <p>A new subarray can also be accessed by using <code>slice()</code>, which takes a lower and upper bound
                (inclusive):</p>

            <code-block lang="kotlin">
                Teams.select(Teams.deadlines.slice(1, 3))
            </code-block>
            <p>Both arguments for these bounds are optional if using PostgreSQL.</p>
            <p>An array column can also be used as an argument for the <code>ANY</code> and <code>ALL</code> SQL
                operators, either by providing the entire column or a new array expression via <code>slice()</code>:</p>

            <code-block lang="kotlin">
                Teams
                    .selectAll()
                    .where { Teams.budgets[1] lessEq allFrom(Teams.expenses) }

                Teams
                    .selectAll()
                    .where { stringParam(&quot;Member A&quot;) eq anyFrom(Teams.memberNames.slice(1, 4)) }
            </code-block>
        </chapter>
    </chapter>
    <chapter title="How to use Multi-Dimensional Array types" id="how-to-use-multi-dimensional-array-types">
        <p>PostgreSQL database supports the explicit ARRAY data type, which includes support for multi-dimensional arrays.</p>
        <p>Exposed supports columns defined as multi-dimensional arrays, with the stored contents being any
            out-of-the-box or custom data type.
            If the contents are of a type with a supported <code>ColumnType</code> in the <code>exposed-core</code>
            module, the column can be simply defined with that type:</p>

        <code-block lang="kotlin">
            object Teams : Table("teams") {
            val memberIds = array2<UUID>("member_ids")
            val memberNames = array3<String>("member_names")
            val budgets = array2<Double>("budgets")
            }
        </code-block>
        <p>If more control is needed over the base content type, or if the latter is user-defined or from a non-core
            module, the explicit type should be provided to the function:</p>

        <code-block lang="kotlin">
            object Teams : Table("teams") {
            val memberIds = array2<UUID>("member_ids")
            val memberNames = array3<String>("member_names", VarCharColumnType(colLength = 32))
            }
        </code-block>

        <p>A multi-dimensional array column accepts inserts and retrieves stored array contents as a Kotlin nested <code>List</code>:</p>

        <code-block lang="kotlin">
            Teams.insert {
                it[memberIds] = List(5) { List(5) { UUID.randomUUID() } }
                it[memberNames] = List(3) { List(3) { List(3) { i -> "Member ${'A' + i}" } } }
                it[budgets] = listOf(listOf(9999.0, 8888.0))
            }
        </code-block>
    </chapter>
    <chapter title="Custom Data Types" id="custom-data-types">
        <p>If a database-specific data type is not immediately supported by Exposed, any existing and open column type
            class can be extended or
            a custom <code>ColumnType</code> class can be implemented to achieve the same functionality.</p>
        <p>The following examples describe different ways to customize a column type, register a column with the custom
            type,
            and then start using it in transactions.</p>
        <chapter title="Hierarchical tree-like data" id="hierarchical-tree-like-data">
            <p>PostgreSQL provides a data type, <a
                    href="https://www.postgresql.org/docs/current/ltree.html"><code>ltree</code></a>, to represent
                hierarchical tree-like data.</p>
            <p>The hierarchy labels are stored as strings, so the existing <code>StringColumnType</code> class be
                extended with a few overrides:</p>

            <code-block lang="kotlin">
                import org.postgresql.util.PGobject

                class LTreeColumnType : StringColumnType() {
                    override fun sqlType(): String = &quot;LTREE&quot;

                    override fun setParameter(stmt: PreparedStatementApi, index: Int, value: Any?) {
                        val parameterValue: PGobject? = value?.let {
                            PGobject().apply {
                                type = sqlType()
                                this.value = value as? String
                            }
                        }
                        super.setParameter(stmt, index, parameterValue)
                    }
                }
            </code-block>
            <note>
                When setting an object in a prepared statement with JDBC, any unknown data type without
                a JDBC mapping is set as a varying character string.
                To avoid a casting exception due to PostgreSQL's stricter type system, the type of the set parameter
                should be manually declared,
                by using a <code>PGobject</code> in <code>setParamater()</code>, as shown in the example above.
            </note>
            <p>A table extension function can then be added to register a new column with this type:</p>
            <code-block lang="kotlin"><![CDATA[
                fun Table.ltree(name: String): Column<String> = registerColumn(name, LTreeColumnType())

                object TestTable : Table("test_table") {
                    val path = ltree("path")

                    init {
                        index(customIndexName = "path_gist_idx", indexType = "GIST", columns = arrayOf(path))
                        index(customIndexName = "path_idx", indexType = "BTREE", columns = arrayOf(path))
                    }
                }
            ]]></code-block>
            <note>
                To use the <code>ltree</code> data type, the extension must first be enabled in the
                    database by running <code>exec(&quot;CREATE EXTENSION ltree;&quot;)</code>.
            </note>
            <p>String values representing hierarchy labels can then be inserted and queried from the <code>path</code>
                column.
                The following block shows an update of all records that have a stored <code>path</code> either equal to
                or a descendant of the path <code>Top.Science</code>,
                by setting a subpath of the first 2 labels as the updated value:</p>

            <code-block lang="kotlin"><![CDATA[
                transaction {
                    TestTable.update(
                        where = { TestTable.path isDescendantOrEq "Top.Science" }
                    ) {
                        it[path] = path.subltree(0, 2)
                    }
                }

                fun <T : String?> Expression<T>.subltree(start: Int, end: Int) =
                    CustomStringFunction("SUBLTREE", this, intParam(start), intParam(end))

                infix fun <T : String?> ExpressionWithColumnType<T>.isDescendantOrEq(other: T) =
                    IsDescendantOrEqOp(this, wrap(other))

                class IsDescendantOrEqOp<T : String?>(
                    left: Expression<T>,
                    right: Expression<T>
                ) : ComparisonOp(left, right, "<@")
            ]]></code-block>
        </chapter>
        <chapter title="Date and time data" id="date-and-time-data">
            <p>MySQL and MariaDB provide a data type, <a href="https://dev.mysql.com/doc/refman/8.4/en/year.html"><code>YEAR</code></a>,
                for 1-byte storage of year values in the range of 1901 to 2155.</p>
            <p>This example assumes that the column accepts string input values, but a numerical format is also
                possible, in which case
                <code>IntegerColumnType</code> could be extended instead:</p>

            <code-block lang="kotlin"><![CDATA[
                class YearColumnType : StringColumnType(), IDateColumnType {
                    override fun sqlType(): String = "YEAR"

                    override val hasTimePart: Boolean = false

                    override fun valueFromDB(value: Any): String = when (value) {
                        is java.sql.Date -> value.toString().substringBefore('-')
                        else -> error("Retrieved unexpected value of type ${value::class.simpleName}")
                    }
                }

                fun Table.year(name: String): Column<String> = registerColumn(name, YearColumnType())
            ]]></code-block>
            <p>The <code>IDateColumnType</code> interface is implemented to ensure that any default expressions are
                handled appropriately. For example,
                a new object <code>CurrentYear</code> can be added as a default to avoid issues with the strict column
                typing:</p>

            <code-block lang="kotlin"><![CDATA[
                object CurrentYear : Function<String>(YearColumnType()) {
                    override fun toQueryBuilder(queryBuilder: QueryBuilder) {
                        queryBuilder { +"CURRENT_DATE" }
                    }
                }

                object TestTable : Table("test_table") {
                    val established = year("established").defaultExpression(CurrentYear)
                }
            ]]></code-block>
            <p>String values of different formats (depending on the enabled <code>sql_mode</code>) can then be inserted
                and queried from the <code>year</code> column:</p>

            <code-block lang="kotlin">
                transaction {
                    // disable strict mode to allow truncation of full date strings
                    exec("SET sql_mode=''")

                    val yearData = listOf("1901", "2000", "2023-08-22", "2155")
                    TestTable.batchInsert(yearData) { year ->
                        this[TestTable.established] = year
                    }

                    TestTable
                        .selectAll()
                        .where { TestTable.established less CurrentYear }
                        .toList()
                }
            </code-block>
        </chapter>
        <chapter title="Ranges of data" id="ranges-of-data">
            <p>PostgreSQL provides multiple <a href="https://www.postgresql.org/docs/16/rangetypes.html">range data
                types</a> of different subtypes.</p>
            <p>If more than one range subtype needs to be used, a base <code>RangeColumnType</code> class could be first
                introduced with the minimum common logic:</p>

            <code-block lang="kotlin"><![CDATA[
                import org.postgresql.util.PGobject

                abstract class RangeColumnType<T : Comparable<T>, R : ClosedRange<T>>(
                    val subType: ColumnType<T>,
                ) : ColumnType<R>() {
                    abstract fun List<String>.toRange(): R

                    override fun nonNullValueToString(value: R): String {
                        return "[${value.start},${value.endInclusive}]"
                    }

                    override fun nonNullValueAsDefaultString(value: R): String {
                        return "'${nonNullValueToString(value)}'"
                    }

                    override fun setParameter(stmt: PreparedStatementApi, index: Int, value: Any?) {
                        val parameterValue: PGobject? = value?.let {
                            PGobject().apply {
                                type = sqlType()
                                this.value = nonNullValueToString(it as R)
                            }
                        }
                        super.setParameter(stmt, index, parameterValue)
                    }

                    override fun valueFromDB(value: Any): R? = when (value) {
                        is PGobject -> value.value?.let {
                            val components = it.trim('[', ')').split(',')
                            components.toRange()
                        }
                        else -> error("Retrieved unexpected value of type ${value::class.simpleName}")
                    }
                }
            ]]></code-block>
            <p>A class for the type <code>int4range</code> that accepts <code>IntRange</code> values could then be
                implemented:</p>

            <code-block lang="kotlin"><![CDATA[
                class IntRangeColumnType : RangeColumnType<Int, IntRange>(IntegerColumnType()) {
                    override fun sqlType(): String = "INT4RANGE"

                    override fun List<String>.toRange(): IntRange {
                        return IntRange(first().toInt(), last().toInt() - 1)
                    }
                }

                fun Table.intRange(name: String): Column<IntRange> = registerColumn(name, IntRangeColumnType())
            ]]></code-block>
            <p>If a custom Kotlin implementation for a <code>DateRange</code> is set up (using <code>Iterable</code> and
                <code>ClosedRange</code>),
                then a class for the type <code>daterange</code> can also be added. This implementation would require a
                dependency on <code>exposed-kotlin-datetime</code>:</p>

            <code-block lang="kotlin"><![CDATA[
                class DateRangeColumnType : RangeColumnType<LocalDate, DateRange>(KotlinLocalDateColumnType()) {
                    override fun sqlType(): String = "DATERANGE"

                    override fun List<String>.toRange(): DateRange {
                        val endInclusive = LocalDate.parse(last()).minus(1, DateTimeUnit.DAY)
                        return DateRange(LocalDate.parse(first()), endInclusive)
                    }
                }

                fun Table.dateRange(name: String): Column<DateRange> = registerColumn(name, DateRangeColumnType())
            ]]></code-block>
            <p>These new column types can be used in a table definition:</p>

            <code-block lang="kotlin">
                object TestTable : Table("test_table") {
                    val amounts = intRange("amounts").default(1..10)
                    val holidays = dateRange("holidays")
                }
            </code-block>
            <p>With the addition of some custom functions, the stored data can then be queried to return the upper bound
                of the date range
                for all records that have an integer range within the specified bounds:</p>

            <code-block lang="kotlin"><![CDATA[
                transaction {
                    val holidayEnd = TestTable.holidays.upperBound()
                    TestTable
                        .select(holidayEnd)
                        .where { TestTable.amounts isContainedBy 0..100 }
                        .toList()
                }

                fun <T : Comparable<T>, CR : ClosedRange<T>, R : CR?> ExpressionWithColumnType<R>.upperBound() =
                    CustomFunction("UPPER", (columnType as RangeColumnType<T, CR>).subType, this)

                infix fun <R : ClosedRange<*>?> ExpressionWithColumnType<R>.isContainedBy(other: R) =
                    RangeIsContainedOp(this, wrap(other))

                class RangeIsContainedOp<R : ClosedRange<*>?>(
                    left: Expression<R>,
                    right: Expression<R>
                ) : ComparisonOp(left, right, "<@")
            ]]></code-block>
        </chapter>
        <chapter title="Predefined string data" id="predefined-string-data">
            <p>MySQL and MariaDB provide a data type, <a href="https://dev.mysql.com/doc/refman/8.4/en/set.html"><code>SET</code></a>,
                for strings that can have zero or more values from a defined list of permitted values.
                This could be useful, for example, when storing a list of Kotlin enum constants.</p>
            <p>To use this type, a new <code>ColumnType</code> could be implemented with all the necessary overrides.
                This example instead takes advantage of
                the existing logic in <code>StringColumnType</code> as the base for database storage, then uses a custom
                <code>ColumnTransformer</code> to achieve the final
                transformation between a set of enum constants and a string:</p>

            <code-block lang="kotlin"><![CDATA[
                class SetColumnType<T : Enum<T>>(
                    private val enumClass: KClass<T>
                ) : StringColumnType() {
                    // uses reflection to retrieve elements of the enum class
                    private val enumConstants by lazy {
                        enumClass.java.enumConstants?.map { it.name } ?: emptyList()
                    }

                    override fun sqlType(): String = enumConstants
                        .takeUnless { it.isEmpty() }
                        ?.let { "SET(${it.joinToString { e -> "'$e'" }})" }
                        ?: error("SET column must be defined with a list of permitted values")
                }

                inline fun <reified T : Enum<T>> Table.set(name: String): Column<String> =
                    registerColumn(name, SetColumnType(T::class))

                class EnumListColumnType<T : Enum<T>>(
                    private val enumClass: KClass<T>
                ) : ColumnTransformer<String, List<T>> {
                    private val enumConstants by lazy {
                        enumClass.java.enumConstants?.associateBy { it.name } ?: emptyMap()
                    }

                    override fun unwrap(value: List<T>): String {
                        return value.joinToString(separator = ",") { it.name }
                    }

                    override fun wrap(value: String): List<T> = value
                        .takeUnless { it.isEmpty() }?.let {
                            it.split(',').map { e ->
                                enumConstants[e]
                                    ?: error("$it can't be associated with any value from ${enumClass.qualifiedName}")
                            }
                        }
                        ?: emptyList()
                }
            ]]></code-block>
            <tip>
                See <a anchor="column-transformation">column
                    transformations</a> for more details about <code>ColumnTransformer</code>.
            </tip>
            <p>The new column type and transformer can then be used in a table definition:</p>

            <code-block lang="kotlin"><![CDATA[
                enum class Vowel { A, E, I, O, U }

                object TestTable : Table("test_table") {
                    val vowel: Column<List<Vowel>> = set<Vowel>("vowel")
                        .transform(EnumListColumnType(Vowel::class))
                        .default(listOf(Vowel.A, Vowel.E))
                }
            ]]></code-block>
            <p>Lists of enum constants can then be inserted and queried from the <code>set</code> column. The following
                block shows a query for all records that
                have <code>Vowel.O</code> stored at any position in the <code>set</code> column string:</p>

            <code-block lang="kotlin"><![CDATA[
                transaction {
                    TestTable.insert { it[vowel] = listOf(Vowel.U, Vowel.E) }
                    TestTable.insert { it[vowel] = emptyList() }
                    TestTable.insert { it[vowel] = Vowel.entries }

                    TestTable
                        .selectAll()
                        .where { TestTable.vowel.findInSet(Vowel.O) greater 0 }
                        .toList()
                }

                fun <T : Enum<T>> Expression<List<T>>.findInSet(enum: T) =
                    CustomFunction("FIND_IN_SET", IntegerColumnType(), stringParam(enum.name), this)
            ]]></code-block>
        </chapter>
        <chapter title="Key-Value pair data" id="key-value-pair-data">
            <p>PostgreSQL provides a data type, <a
                    href="https://www.postgresql.org/docs/16/hstore.html"><code>hstore</code></a>, to store key-value
                data pairs in a single text string.</p>
            <p>The existing <code>StringColumnType</code> class can be extended with a few overrides:</p>

            <code-block lang="kotlin">
                import org.postgresql.util.PGobject

                class HStoreColumnType : TextColumnType() {
                    override fun sqlType(): String = "HSTORE"

                    override fun setParameter(stmt: PreparedStatementApi, index: Int, value: Any?) {
                        val parameterValue: PGobject? = value?.let {
                            PGobject().apply {
                                type = sqlType()
                                this.value = value as? String
                            }
                        }
                        super.setParameter(stmt, index, parameterValue)
                    }
                }
            </code-block>
            <p>A table extension function can then be added to register a new column with this type.
                This example assumes that the input values will be of type <code>Map&lt;String, String&gt;</code>, so
                <code>transform()</code> is used on the string column to handle parsing:</p>

            <code-block lang="kotlin">
                fun Table.hstore(name: String): Column&lt;String&gt; = registerColumn(name, HStoreColumnType())

                object TestTable : Table(&quot;test_table&quot;) {
                    val bookDetails = hstore(&quot;book_details&quot;).transform(
                        wrap = {
                            it.trim('{', '}').split(", ")
                                .associate { pair ->
                                    pair.substringBefore("=") to pair.substringAfter("=")
                                }
                        },
                        unwrap = {
                            it.entries.joinToString(separator = ",") { (k, v) ->
                                "\"$k\"=>\"$v\""
                            }
                        }
                    )
                }
            </code-block>
            <tip>
                See <a anchor="column-transformation">column
                    transformations</a> for more details about <code>transform()</code>.
            </tip>
            <note>
                To use the <code>hstore</code> data type, the extension must first be enabled in the
                    database by running <code>exec(&quot;CREATE EXTENSION hstore;&quot;)</code>.
            </note>
            <p>Map values representing key-value pairs of strings can then be inserted and queried from the <code>bookDetails</code>
                column.
                The following block queries the value associated with the <code>title</code> key from all <code>bookDetails</code>
                records:</p>

            <code-block lang="kotlin"><![CDATA[
                transaction {
                    TestTable.insert {
                        it[bookDetails] = mapOf(
                            "title" to "Kotlin in Action",
                            "edition" to "2"
                        )
                    }

                    val bookTitle = TestTable.bookDetails.getValue("title")
                    TestTable
                        .select(bookTitle)
                        .toList()
                }

                fun <T : Map<String, String>> Expression<T>.getValue(key: String) =
                    CustomOperator("->", TextColumnType(), this, stringParam(key))
            ]]></code-block>
        </chapter>
        <chapter title="Case insensitive data" id="case-insensitive-data">
            <p>PostgreSQL provides a data type, <a
                    href="https://www.postgresql.org/docs/16/citext.html"><code>citext</code></a>, that represents a
                case-insensitive string type.</p>
            <p>The existing <code>StringColumnType</code> class can be extended with a few overrides:</p>

            <code-block lang="kotlin">
                import org.postgresql.util.PGobject

                class CitextColumnType(
                    colLength: Int
                ) : VarCharColumnType(colLength) {
                    override fun sqlType(): String = &quot;CITEXT&quot;

                    override fun setParameter(stmt: PreparedStatementApi, index: Int, value: Any?) {
                        val parameterValue: PGobject? = value?.let {
                            PGobject().apply {
                                type = sqlType()
                                this.value = value as? String
                            }
                        }
                        super.setParameter(stmt, index, parameterValue)
                    }
                }
            </code-block>
            <p>A table extension function can then be added to register a new column with this type:</p>

            <code-block lang="kotlin">
                fun Table.citext(name: String, length: Int): Column&lt;String&gt; =
                    registerColumn(name, CitextColumnType(length))

                object TestTable : Table(&quot;test_table&quot;) {
                    val firstName = citext(&quot;first_name&quot;, 32)
                }
            </code-block>
            <note>
                <p>To use the <code>citext</code> data type, the extension must first be enabled in the
                    database by running <code>exec(&quot;CREATE EXTENSION citext;&quot;)</code>.</p>
            </note>
            <p>String values can then be inserted and queried from the <code>firstName</code> column in a
                case-insensitive manner:</p>

            <code-block lang="kotlin">
                transaction {
                    val allNames = listOf(&quot;Anna&quot;, &quot;Anya&quot;, &quot;Agna&quot;)
                    TestTable.batchInsert(allNames) { name -&gt;
                        this[TestTable.firstName] = name
                    }

                    TestTable
                        .selectAll()
                        .where { TestTable.firstName like &quot;an%&quot; }
                        .toList()
                }
            </code-block>
        </chapter>
    </chapter>
    <chapter title="Column transformation" id="column-transformation">
        <p>Column transformations allow to define custom transformations between database column types and application's
            data types.
            This can be particularly useful when you need to store data in one format but work with it in another format
            within your application.</p>
        <p>Consider the following example, where we define a table to store meal times and transform these times into
            meal types:</p>

        <code-block lang="kotlin">
            enum class Meal {
                BREAKFAST,
                LUNCH,
                DINNER
            }

            object Meals : Table() {
                val mealTime: Column&lt;Meal&gt; = time(&quot;meal_time&quot;)
                    .transform(
                        wrap = {
                            when {
                                it.hour &lt; 10 -&gt; Meal.BREAKFAST
                                it.hour &lt; 15 -&gt; Meal.LUNCH
                                else -&gt; Meal.DINNER
                            }
                        },
                        unwrap = {
                            when (it) {
                                Meal.BREAKFAST -&gt; LocalTime(8, 0)
                                Meal.LUNCH -&gt; LocalTime(12, 0)
                                Meal.DINNER -&gt; LocalTime(18, 0)
                            }
                        }
                    )
            }
        </code-block>
        <p>The <code>transform</code> function is used to apply custom transformations to the <code>mealTime</code>
            column:</p>
        <list>
            <li>The <code>wrap</code> function transforms the stored <code>LocalTime</code> values into
                <code>Meal</code> enums. It checks the hour of the stored time and returns the corresponding meal type.
            </li>
            <li>The <code>unwrap</code> function transforms <code>Meal</code> enums back into <code>LocalTime</code>
                values for storage in the database.
            </li>
        </list>
        <p>Transformation could be also defined as an implementation of <code>ColumnTransformer</code> interface and
            reused among different tables:</p>

        <code-block lang="kotlin">
            class MealTimeTransformer : ColumnTransformer&lt;LocalTime, Meal&gt; {
                override fun wrap(value: LocalTime): Meal = when {
                    value.hour &lt; 10 -&gt; Meal.BREAKFAST
                    value.hour &lt; 15 -&gt; Meal.LUNCH
                    else -&gt; Meal.DINNER
                }

                override fun unwrap(value: Meal): LocalTime = when (value) {
                    Meal.BREAKFAST -&gt; LocalTime(8, 0)
                    Meal.LUNCH -&gt; LocalTime(12, 0)
                    Meal.DINNER -&gt; LocalTime(18, 0)
                }
            }

            object Meals : Table() {
                val mealTime: Column&lt;Meal&gt; = time(&quot;meal_time&quot;).transform(MealTimeTransformer())
            }
        </code-block>

    <chapter title="Null transform" id="null-transform">
        <p>
            Special case is <code>nullTransform()</code> method.
            That method applies a special transformation that allows a non-nullable database column
            to accept and/or return values as `null` on the client side.
        </p>

        <p>
            This transformation does not alter the column's definition in the database,
            which will still be <code>NON NULL</code>. It enables reflecting non-null values
            from the database as <code>null</code> in Kotlin (e.g., converting an empty string from a
            non-nullable text column, empty lists, negative IDs, etc., to <code>null</code>).
        </p>

        <code-block lang="kotlin">
            class MealTimeNullTransformer : ColumnTransformer&lt;LocalTime, Meal?&gt; {
                override fun wrap(value: LocalTime): Meal? = when {
                    value.hour &lt; 10 -&gt; Meal.BREAKFAST
                    value.hour &lt; 15 -&gt; Meal.LUNCH
                    else -&gt; Meal.DINNER
                }

                override fun unwrap(value: Meal?): LocalTime = when (value) {
                    Meal.BREAKFAST -&gt; LocalTime(8, 0)
                    Meal.LUNCH -&gt; LocalTime(12, 0)
                    Meal.DINNER -&gt; LocalTime(18, 0)
                    else -&gt; LocalTime(0, 0)
                }
            }

            object Meals : Table() {
                val mealTime: Column&lt;Meal?&gt; = time(&quot;meal_time&quot;).transform(MealTimeNullTransformer())
            }
        </code-block>
    </chapter>
    </chapter>
</topic>
