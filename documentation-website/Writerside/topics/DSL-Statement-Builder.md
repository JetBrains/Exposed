<show-structure for="chapter,procedure" depth="2"/>

# Statement Builder

Exposed DSL provides various functions to perform database operations, such as [](DSL-CRUD-operations.topic).
In the event that the SQL generated by this DSL needs to be accessed without first being sent to the database for execution,
Exposed also provides this functionality through [`Statement.prepareSQL()`](https://jetbrains.github.io/Exposed/api/exposed-core/org.jetbrains.exposed.v1.core.statements/-statement/prepare-s-q-l.html).

The following examples refer to the [`StarWarsFilmsTable`](DSL-Table-Types.topic) defined previously, and any generated
SQL is based on output from the H2 database.

<note>
This functionality still requires a connection and transaction context, since Exposed adapts its statement and query
building dynamically based on the underlying database, primarily for identifier and syntax specifics.
</note>

## Read operations

<tldr>
    <p>API References: <a href="https://jetbrains.github.io/Exposed/api/exposed-jdbc/org.jetbrains.exposed.v1.jdbc/-query/index.html"><code>Query</code> (JDBC)</a>, 
    <a href="https://jetbrains.github.io/Exposed/api/exposed-r2dbc/org.jetbrains.exposed.v1.r2dbc/-query/index.html"><code>Query</code> (R2DBC)</a>  
    </p>
</tldr>

An instance of a `Query`will not be executed until an attempt is made to iterate over or consume the results returned from the database.
For this reason, queries can be built and stored for later use:

```kotlin
val filmQuery = StarWarsFilmsTable
    .selectAll()
    .where { StarWarsFilmsTable.sequelId lessEq 3 }
```

`.prepareSQL()` could then be called to check the SQL string representation of the query that would be sent to the database:

```kotlin
val querySql: String = filmQuery
    .orWhere { StarWarsFilmsTable.sequelId greater 6 }
    .prepareSQL(this)
```
```sql
SELECT STARWARSFILMS.ID, STARWARSFILMS.SEQUEL_ID, STARWARSFILMS."name", STARWARSFILMS.DIRECTOR
FROM STARWARSFILMS
WHERE (STARWARSFILMS.SEQUEL_ID <= ?) OR (STARWARSFILMS.SEQUEL_ID > ?)
```

By default, a parameterized SQL string is prepared and returned. To generate a string without parameter placeholders,
set the `prepared` argument to `false`:

```kotlin
val querySql: String = filmQuery
    .orWhere { StarWarsFilmsTable.sequelId greater 6 }
    .prepareSQL(this, prepared = false)
```
```sql
SELECT STARWARSFILMS.ID, STARWARSFILMS.SEQUEL_ID, STARWARSFILMS."name", STARWARSFILMS.DIRECTOR
FROM STARWARSFILMS
WHERE (STARWARSFILMS.SEQUEL_ID <= 3) OR (STARWARSFILMS.SEQUEL_ID > 6)
```

## Other operations

When calling a function like [`.insert()`](DSL-CRUD-operations.topic#insert) on a table, the generated SQL is automatically
sent to the database to create a new row. It has always been possible to avoid this by instantiating the underlying statement class directly, namely
[`InsertStatement`](https://jetbrains.github.io/Exposed/api/exposed-core/org.jetbrains.exposed.v1.core.statements/-insert-statement/index.html).

Since version 1.0.0, it is possible to create instances of these underlying statements, without automatic execution, by using
the same DSL inside a [`buildStatement()`](https://jetbrains.github.io/Exposed/api/exposed-core/org.jetbrains.exposed.v1.core.statements/build-statement.html) block:

```kotlin
val insertFilm = buildStatement {
    StarWarsFilmsTable.insert {
        it[sequelId] = 8
        it[name] = "The Last Jedi"
        it[director] = "Rian Johnson"
    }
}
```

Just as for [queries](#read-operations), the SQL string that would be executed can be accessed using `.prepareSQL()`:

```kotlin
val preparedSql: String = insertFilm.prepareSQL(this, prepared = true)
```
```sql
INSERT INTO STARWARSFILMS (SEQUEL_ID, "name", DIRECTOR) VALUES (?, ?, ?)
```

```kotlin
val fullSql: String = insertFilm.prepareSQL(this, prepared = false)
```
```sql
INSERT INTO STARWARSFILMS (SEQUEL_ID, "name", DIRECTOR) VALUES (8, 'The Last Jedi', 'Rian Johnson')
```

### Executing a statement

<tldr>
    <p>API References: <a href="https://jetbrains.github.io/Exposed/api/exposed-jdbc/org.jetbrains.exposed.v1.jdbc/-jdbc-transaction/exec.html"><code>exec</code> (JDBC)</a>, 
    <a href="https://jetbrains.github.io/Exposed/api/exposed-r2dbc/org.jetbrains.exposed.v1.r2dbc/-r2dbc-transaction/exec.html"><code>exec</code> (R2DBC)</a>  
    </p>
</tldr>

A stored `Statement` could still be sent to the database at some point by first passing it to an executable class, either a subclass
of [`BlockingExecutable`](https://jetbrains.github.io/Exposed/api/exposed-jdbc/org.jetbrains.exposed.v1.jdbc.statements/-blocking-executable/index.html) (JDBC)
or [`SuspendExecutable`](https://jetbrains.github.io/Exposed/api/exposed-r2dbc/org.jetbrains.exposed.v1.r2dbc.statements/-suspend-executable/index.html) (R2DBC).
The executable can then be sent to the database using `exec()` in a transaction block.

This can be done manually, if the appropriate class is known or a custom statement or executable class is being used:

```kotlin
exec(InsertBlockingExecutable(insertFilm))
```

Alternatively, if the statement being used is sourced from the Exposed API, `Statement.toExecutable()` can be used to
resolve the appropriate executable class instance for the calling statement type:

```kotlin
exec(insertFilm.toExecutable())
```
