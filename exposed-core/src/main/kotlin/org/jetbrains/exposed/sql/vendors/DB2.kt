package org.jetbrains.exposed.sql.vendors

import org.jetbrains.exposed.exceptions.UnsupportedByDialectException
import org.jetbrains.exposed.exceptions.throwUnsupportedException
import org.jetbrains.exposed.sql.*
import org.jetbrains.exposed.sql.transactions.TransactionManager
import org.jetbrains.exposed.sql.vendors.db2compat.DB2ResultSet
import java.lang.reflect.Method
import java.sql.PreparedStatement
import java.sql.ResultSet

internal object DB2DataTypeProvider : DataTypeProvider() {
    override fun binaryType(): String {
        exposedLogger.error("The length of the Binary column is missing.")
        error("The length of the Binary column is missing.")
    }

    override fun byteType(): String = "SMALLINT"

    override fun ubyteType(): String = "SMALLINT"

    override fun dateTimeType(): String = "TIMESTAMP"

    override fun ulongType(): String = "BIGINT"

    override fun textType(): String = "CLOB"

    override fun uuidType(): String = "CHAR(16) FOR BIT DATA"

    override fun integerAutoincType(): String = "INT NOT NULL GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1)"

    override fun longAutoincType(): String = "BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1)"
}

internal object DB2FunctionProvider : FunctionProvider() {

    override val DEFAULT_VALUE_EXPRESSION: String = "VALUES DEFAULT"

    override fun random(seed: Int?) = "RAND(${seed?.toString().orEmpty()})"

    override fun delete(ignore: Boolean, table: Table, where: String?, limit: Int?, transaction: Transaction): String {
        if (!DB2Dialect.ENABLE_UPDATE_DELETE_LIMIT && limit != null) {
            transaction.throwUnsupportedException("SQLite doesn't support LIMIT in UPDATE clause.")
        }
        return super.delete(ignore, table, where, limit, transaction)
    }

    override fun update(
        targets: Join,
        columnsAndValues: List<Pair<Column<*>, Any?>>,
        limit: Int?,
        where: Op<Boolean>?,
        transaction: Transaction
    ): String = with(QueryBuilder(true)) {
        columnsAndValues.map { it.first.table }.distinct().singleOrNull()
            ?: transaction.throwUnsupportedException("DB2 supports a join updates with a single table columns to update.")
        if (targets.joinParts.any { it.joinType != JoinType.INNER }) {
            exposedLogger.warn("All tables in UPDATE statement will be joined with inner join")
        }
        +"UPDATE ("
        val columnsToSelect = columnsAndValues.flatMap {
            listOfNotNull(it.first, it.second as? Expression<*>)
        }.mapIndexed { index, expression -> expression to expression.alias("c$index") }.toMap()

        val subQuery = targets.slice(columnsToSelect.values.toList()).selectAll()
        where?.let {
            subQuery.adjustWhere { it }
        }
        subQuery.prepareSQL(this)
        +") x"

        columnsAndValues.appendTo(this, prefix = " SET ") { (col, value) ->
            val alias = columnsToSelect.getValue(col)
            +alias.alias
            +"="
            (value as? Expression<*>)?.let {
                +columnsToSelect.getValue(it).alias
            } ?: registerArgument(col, value)
        }

        limit?.let {
            "WHERE ROWNUM <= $it"
        }

        toString()
    }

    override fun concat(
        separator: String,
        queryBuilder: QueryBuilder,
        vararg expr: Expression<*>
    ): Unit = queryBuilder {
        if (separator == "") {
            expr.appendTo(separator = " || ") { +it }
        } else {
            expr.appendTo(separator = " || '$separator' || ") { +it }
        }
    }

    override fun <T : String?> groupConcat(
        expr: GroupConcat<T>,
        queryBuilder: QueryBuilder
    ): Unit = queryBuilder {
        if (expr.orderBy.size != 1) {
            TransactionManager.current().throwUnsupportedException("DB2 supports only single column in ORDER BY clause in LISTAGG")
        }
        append("LISTAGG(")
        append(expr.expr)
        expr.separator?.let {
            append(", '$it'")
        }
        append(") WITHIN GROUP (ORDER BY ")
        val (col, order) = expr.orderBy.single()
        append(col, " ", order.name, ")")
    }

    override fun queryLimit(size: Int, offset: Long, alreadyOrdered: Boolean): String {
        return (if (offset > 0) " OFFSET $offset ROWS" else "") + " FETCH FIRST $size ROWS ONLY"
    }

}

/**
 * DB2 dialect implementation.
 */
class DB2Dialect : VendorDialect(dialectName, DB2DataTypeProvider, DB2FunctionProvider) {
    override val name: String = dialectName
    override val supportsOnlyIdentifiersInGeneratedKeys: Boolean = true
    override val supportsIfNotExists: Boolean = false


    override fun createDatabase(name: String): String {
        throw UnsupportedByDialectException("Create database can only run in clp(command line processor), thus it can not run here", currentDialect)
    }

    override fun dropDatabase(name: String): String {
        throw UnsupportedByDialectException("Drop database can only run in clp(command line processor), thus it can not run here", currentDialect)
    }

    override fun createIndex(index: Index): String {
        return super.createIndex(index)
    }

    override fun createSchema(schema: Schema): String = buildString {
        append("CREATE SCHEMA ")
        append(schema.identifier)

        if (schema.authorization != null) {
            append(" ")
            append("AUTHORIZATION ")
            append(schema.authorization)
        }
    }

    override fun modifyColumn(column: Column<*>, columnDiff: ColumnDiff): List<String>  {
        val sqls = mutableListOf<String>()
        val identify = TransactionManager.current().identity(column)
        val ddlSql = "ALTER TABLE ${TransactionManager.current().identity(column.table)} ALTER COLUMN " +
            column.descriptionDdl(true).replace("NOT NULL", "")
                .replace("MODIFY", "ALTER")
                .replace(identify, "$identify SET DATA TYPE ")
        sqls += ddlSql



        if (columnDiff.nullability) {
            val nullableSql = if (column.columnType.nullable) {
                "ALTER TABLE ${TransactionManager.current().identity(column.table)} ALTER COLUMN $identify DROP NOT NULL"
            } else {
                "ALTER TABLE ${TransactionManager.current().identity(column.table)} ALTER COLUMN $identify SET NOT NULL"
            }
            sqls += nullableSql
        }
        sqls += "CALL SYSPROC.ADMIN_CMD('REORG TABLE ${TransactionManager.current().identity(column.table)}')"

        return sqls
    }


    override fun dropSchema(schema: Schema, cascade: Boolean): String {
        if (cascade) {
            throw UnsupportedByDialectException(
                "${currentDialect.name} There is no cascading drop function in DB2; you will have to drop each individual object that uses that schema first",
                currentDialect
            )
        }
        return "DROP SCHEMA ${schema.identifier} RESTRICT"
    }

    companion object {
        /** DB2 dialect name */
        const val dialectName: String = "db2"

        // todo it not supported in earlier verion
        val ENABLE_UPDATE_DELETE_LIMIT = true
    }
}

private val DB2Class by lazy { Class.forName("com.ibm.db2.jcc.DB2PreparedStatement") as Class<out PreparedStatement?> }
val GET_DB_GENERATED_KEYS: Method by lazy { DB2Class.getDeclaredMethod("getDBGeneratedKeys"); }

val PreparedStatement.db2ResultSetCompat: ResultSet
    get() {
        @Suppress("UNCHECKED_CAST")
        return DB2ResultSet((GET_DB_GENERATED_KEYS.invoke(this) as Array<ResultSet>))
    }
