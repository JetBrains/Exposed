package org.jetbrains.exposed.sql

/**
 * Represents a default value for a column.
 *
 * Commonly it should be implementation of [ClientColumnDefault] or [DatabaseColumnDefault] interfaces.
 */
interface ColumnDefault<T>

/**
 * Represents a client-side default value for a column.
 *
 * The column with [ClientColumnDefault] default value will not affect DDL,
 * and will be automatically added to all the insert/upsert statements
 */
interface ClientColumnDefault<T> : ColumnDefault<T>

/**
 * Represents a database-side default value for a column.
 *
 * The [DatabaseColumnDefault] default value will be used for DDL generation,
 * and will not be added to insert/upsert statements automatically.
 */
interface DatabaseColumnDefault<T> : ColumnDefault<T>

/**
 * Represents a default value for a column generated by an SQL expression.
 */
interface ColumnDefaultExpression<T> : ColumnDefault<T> {
    val expression: Expression<T>
}

/**
 * Represents a default value for a column generated by a function.
 */
interface ColumnDefaultValue<T> : ColumnDefault<T> {
    val value: () -> T
}

/**
 * A column default value that can be transformed.
 */
interface TransformableColumnDefault<Unwrapped> : ColumnDefault<Unwrapped> {
    /**
     * Creates new default value based on the transformation function
     *
     * @param fn The transformation function.
     * @return The transformed column default value.
     */
    fun <Wrapped> transform(fn: (Unwrapped) -> Wrapped): ColumnDefault<Wrapped>
}

/**
 * Represents a client-side default value for a column, implemented as a function.
 */
class ClientColumnDefaultValue<T>(override val value: () -> T) :
    ColumnDefaultValue<T>, ClientColumnDefault<T>, TransformableColumnDefault<T> {

    override fun <Wrapped> transform(fn: (T) -> Wrapped): ColumnDefault<Wrapped> =
        ClientColumnDefaultValue { fn(value()) }
}

/**
 * Represents a database-side generated column default value.
 */
class DatabaseGeneratedColumnDefault<T> : DatabaseColumnDefault<T>

/**
 * Represents a database-side column default value generated by an SQL expression.
 */
class DatabaseColumnDefaultExpression<T>(override val expression: Expression<T>) :
    ColumnDefaultExpression<T>, DatabaseColumnDefault<T>

/**
 * Represents a database-side column default value generated by expression
 * that also contains in-memory kotlin value.
 *
 * It's still database default value, so Exposed will expect that the value will be
 * generated on the database side. But DAO layer could use in-memory value to
 * give the user possibility to access data before actual commit.
 */
class DatabaseColumnDefaultExpressionWithValue<T>(
    override val expression: Expression<T>,
    override val value: () -> T
) : ColumnDefaultValue<T>, ColumnDefaultExpression<T>, DatabaseColumnDefault<T>, TransformableColumnDefault<T> {

    @Suppress("UNCHECKED_CAST")
    override fun <Wrapped> transform(fn: (T) -> Wrapped): ColumnDefault<Wrapped> =
        DatabaseColumnDefaultExpressionWithValue(expression as Expression<Wrapped>) { fn(value()) }
}

/**
 * Checks if the column has a database-side default value.
 */
fun Column<*>.hasDatabaseDefault() = default is DatabaseColumnDefault<*>

/**
 * Checks if the column has a client-side default value.
 */
fun Column<*>.hasClientDefault() = default is ClientColumnDefault<*>

/**
 * Checks if the column has a default value.
 */
fun Column<*>.hasDefaultValue() = default is ColumnDefaultValue<*>

/**
 * Gets the default value of the column if it exists.
 *
 * @return The default value, or null if none exists.
 */
fun <T> Column<T>.defaultValue() = (default as? ColumnDefaultValue<T>)?.value?.invoke()

/**
 * Checks if the column has a client-side default value.
 */
fun Column<*>.hasClientDefaultValue() = default is ClientColumnDefaultValue<*>

/**
 * Gets the client-side default value of the column if it exists.
 *
 * @return The client-side default value, or null if none exists.
 */
fun <T> Column<T>.clientDefaultValue() = (default as? ClientColumnDefaultValue<T>)?.value?.invoke()

/**
 * Gets the database-side default SQL expression if it exists.
 *
 * @return The SQL expression, or null if none exists.
 */
fun <T> Column<T>.databaseDefaultExpression() =
    if (default is DatabaseColumnDefault) (default as? ColumnDefaultExpression<T>)?.expression else null

/**
 * Gets the client-side default value or expression if it exists.
 *
 * @return The client-side default value or SQL expression, or null if none exists.
 */
fun Column<*>.clientDefaultValueOrExpression() = (default as? ClientColumnDefault)?.let {
    when (it) {
        is ColumnDefaultValue<*> -> it.value()
        is ColumnDefaultExpression<*> -> it.expression
        else -> null
    }
}

/**
 * Transforms the column default value using the provided function.
 *
 * @param fn The transformation function.
 * @return The transformed column default value.
 */
fun <Unwrapped, Wrapped> ColumnDefault<Unwrapped>.transform(fn: (Unwrapped) -> Wrapped): ColumnDefault<Wrapped> {
    @Suppress("UNCHECKED_CAST")
    return when (this) {
        is TransformableColumnDefault<Unwrapped> -> transform(fn)
        else -> this as ColumnDefault<Wrapped>
    }
}
