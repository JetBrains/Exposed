package org.jetbrains.exposed.sql.statements.api

import org.jetbrains.exposed.sql.IColumnType
import org.jetbrains.exposed.sql.statements.StatementResult
import java.io.InputStream
import java.sql.PreparedStatement
import java.sql.ResultSet

@Suppress("TooManyFunctions")
interface PreparedStatementApi {

    var fetchSize: Int?

    fun fillParameters(args: Iterable<Pair<IColumnType, Any?>>): Int {
        args.forEachIndexed { index, (c, v) ->
            c.setParameter(this, index + 1, c.valueToDB(v))
        }

        return args.count() + 1
    }

    fun addBatch()

    /**
     * Executes an SQL query stored in a [PreparedStatement].
     *
     * @return The [ResultSet] generated by the query.
     */
    fun executeQuery(): ResultSet

    /**
     * Executes an SQL statement stored in a [PreparedStatement].
     *
     * @return The affected row count if the executed statement is a DML type;
     * otherwise, 0 if the statement returns nothing.
     */
    fun executeUpdate(): Int

    /**
     * Executes multiple SQL statements stored in a single [PreparedStatement].
     *
     * @return A list of [StatementResult]s retrieved from the database, which may store either affected row counts
     * or [ResultSet]s. The order of elements is based on the order of the statements in the `PreparedStatement`.
     */
    fun executeMultiple(): List<StatementResult>

    val resultSet: ResultSet?

    operator fun set(index: Int, value: Any)

    fun setNull(index: Int, columnType: IColumnType)

    fun setInputStream(index: Int, inputStream: InputStream)

    fun closeIfPossible()

    /**
     * Executes batched SQL statements stored as a [PreparedStatement].
     *
     * @return A list of the affected row counts, with one element for each statement,
     * ordered based on the order in which statements were provided to the batch.
     */
    fun executeBatch(): List<Int>

    fun cancel()
}
